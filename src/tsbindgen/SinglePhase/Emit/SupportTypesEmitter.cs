using System.IO;
using System.Text;

namespace tsbindgen.SinglePhase.Emit;

/// <summary>
/// Emits _support/types.d.ts with centralized marker types for unsafe CLR constructs.
/// These markers provide type-safe placeholders for C# constructs with no TS equivalent:
/// - TSUnsafePointer<T> for pointers (void*, int*, etc.)
/// - TSByRef<T> for ref/out/in parameters
/// </summary>
public static class SupportTypesEmit
{
    /// <summary>
    /// Emit the centralized support types file once for the entire generation.
    /// This is not per-namespace - it's a single shared module.
    /// </summary>
    public static void Emit(BuildContext ctx, string outputDirectory)
    {
        ctx.Log("SupportTypesEmit", "Generating _support/types.d.ts...");

        // Create _support directory
        var supportPath = Path.Combine(outputDirectory, "_support");
        Directory.CreateDirectory(supportPath);

        // Generate content
        var content = GenerateSupportTypes();

        // Write to file: output/_support/types.d.ts
        var outputFile = Path.Combine(supportPath, "types.d.ts");
        File.WriteAllText(outputFile, content);

        ctx.Log("SupportTypesEmit", $"  → {outputFile}");
    }

    private static string GenerateSupportTypes()
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// Generated by tsbindgen - Single-Phase Architecture");
        sb.AppendLine("// Support Types Module");
        sb.AppendLine("//");
        sb.AppendLine("// These are opaque placeholders for CLR constructs that have no TS equivalent.");
        sb.AppendLine("// They intentionally erase to `unknown` to keep the API sound.");
        sb.AppendLine();

        // TSUnsafePointer<T> - for pointer types
        sb.AppendLine("/**");
        sb.AppendLine(" * Marker type for C# pointer types (void*, int*, T*, etc.).");
        sb.AppendLine(" * Erases to `unknown` for type safety - forces explicit handling.");
        sb.AppendLine(" * The generic parameter preserves information about the pointed-to type.");
        sb.AppendLine(" * Branded with unique symbol to maintain identity for auditing.");
        sb.AppendLine(" */");
        sb.AppendLine("export type TSUnsafePointer<T> = unknown & { readonly __tsbindgenPtr?: unique symbol };");
        sb.AppendLine();

        // TSByRef<T> - for ref/out/in parameters (structural wrapper)
        sb.AppendLine("/**");
        sb.AppendLine(" * Marker type for C# ref/out/in parameters.");
        sb.AppendLine(" * Provides structural access via `.value` to match C# semantics.");
        sb.AppendLine(" * Branded with unique symbol to maintain identity for auditing.");
        sb.AppendLine(" * Example: `method(arg: TSByRef<int>)` → caller uses `arg.value`");
        sb.AppendLine(" */");
        sb.AppendLine("export type TSByRef<T> = { value: T } & { readonly __tsbindgenByRef?: unique symbol };");
        sb.AppendLine();

        return sb.ToString();
    }
}

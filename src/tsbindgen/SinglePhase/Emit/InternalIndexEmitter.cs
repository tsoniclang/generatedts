using System.Collections.Immutable;
using System.Text;
using tsbindgen.SinglePhase.Emit.Printers;
using tsbindgen.SinglePhase.Model;
using tsbindgen.SinglePhase.Model.Symbols;
using tsbindgen.SinglePhase.Model.Symbols.MemberSymbols;
using tsbindgen.SinglePhase.Model.Types;
using tsbindgen.SinglePhase.Plan;
using tsbindgen.SinglePhase.Renaming;

namespace tsbindgen.SinglePhase.Emit;

/// <summary>
/// Emits internal/index.d.ts files for each namespace.
/// Uses EmitOrder to generate declarations in deterministic order.
/// Orchestrates ClassPrinter, MethodPrinter, TypeRefPrinter.
/// </summary>
public static class InternalIndexEmitter
{
    /// <summary>
    /// Determines if a type should be emitted to .d.ts files.
    /// Only public types are emitted (EmitScope is for members, not types).
    /// </summary>
    public static bool ShouldEmit(TypeSymbol type)
    {
        return type.Accessibility == Accessibility.Public;
    }

    public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
    {
        ctx.Log("InternalIndexEmitter", "Generating TypeScript declarations...");

        var emittedCount = 0;

        // Process each namespace in order
        foreach (var nsOrder in plan.EmissionOrder.Namespaces)
        {
            var ns = nsOrder.Namespace;
            ctx.Log("InternalIndexEmitter", $"  Emitting namespace: {ns.Name}");

            // Generate .d.ts content
            var content = GenerateNamespaceDeclaration(ctx, plan.Graph, plan.Imports, nsOrder);

            // Write to file: output/Namespace.Name/internal/index.d.ts (or _root for empty namespace)
            var namespacePath = Path.Combine(outputDirectory, ns.Name);
            // Use _root for empty namespace to avoid case-sensitivity collision with "Internal" namespace
            var subdirName = ns.IsRoot ? "_root" : "internal";
            var internalPath = Path.Combine(namespacePath, subdirName);
            Directory.CreateDirectory(internalPath);

            var outputFile = Path.Combine(internalPath, "index.d.ts");
            File.WriteAllText(outputFile, content);

            ctx.Log("InternalIndexEmitter", $"    → {outputFile}");
            emittedCount++;
        }

        ctx.Log("InternalIndexEmitter", $"Generated {emittedCount} declaration files");
    }

    private static string GenerateNamespaceDeclaration(BuildContext ctx, SymbolGraph graph, ImportPlan importPlan, NamespaceEmitOrder nsOrder)
    {
        // Create TypeNameResolver - single source of truth for type names
        // TS2693 FIX: Pass ImportPlan and current namespace for qualified name resolution
        var resolver = new TypeNameResolver(ctx, graph, importPlan, nsOrder.Namespace.Name);

        // V2 FIX: Create BindingsProvider for inherited member exposure (TS2416 fix)
        var bindingsProvider = new BindingsProvider(ctx, graph);

        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// Generated by tsbindgen - Single-Phase Architecture");
        sb.AppendLine($"// Namespace: {nsOrder.Namespace.Name}");
        sb.AppendLine($"// Assembly: {string.Join(", ", nsOrder.Namespace.ContributingAssemblies)}");
        sb.AppendLine();

        // Branded primitive types (emitted in all namespaces for cross-namespace type references)
        // Every namespace needs these to reference System types (Int32 → int, etc.)
        EmitBrandedPrimitives(sb);

        // Check if namespace uses unsafe markers (pointers/byrefs) and emit support import if needed
        var needsSupportTypes = NamespaceUsesSupportTypes(nsOrder.Namespace);
        if (needsSupportTypes)
        {
            sb.AppendLine("// Import support types for unsafe CLR constructs");
            // Internal files are at Namespace/internal/index.d.ts, _support is at root level
            sb.AppendLine("import type { TSUnsafePointer, TSByRef } from \"../../_support/types\";");
            sb.AppendLine();
        }

        // Emit import statements for cross-namespace type references
        var imports = importPlan.GetImportsFor(nsOrder.Namespace.Name);
        if (imports.Count > 0)
        {
            sb.AppendLine("// Import types from other namespaces");

            // Sort imports by module specifier for stable output
            foreach (var import in imports.OrderBy(i => i.ImportPath))
            {
                // TS2693 FIX: Use namespace imports for value imports to make them accessible inside namespace blocks
                // TypeScript limitation: named value imports aren't accessible inside namespace declarations
                var valueImports = import.TypeImports.Where(ti => ti.IsValueImport).ToList();
                var typeOnlyImports = import.TypeImports.Where(ti => !ti.IsValueImport).ToList();

                // Emit BOTH named AND namespace imports for reflection types
                // - Named imports work outside namespace blocks (for simple names in return types)
                // - Namespace imports work inside namespace blocks (for base classes)
                // We need both to support reflection types used in both positions
                var reflectionValueImports = valueImports
                    .Where(ti => ReflectionTypes.IsCommonReflectionTypeName(import.TargetNamespace, ti.TypeName))
                    .ToList();

                // Emit named value imports for reflection types (accessible outside namespace)
                if (reflectionValueImports.Count > 0)
                {
                    var reflectionList = string.Join(", ", reflectionValueImports
                        .OrderBy(ti => ti.TypeName)
                        .Select(ti => ti.Alias != null ? $"{ti.TypeName} as {ti.Alias}" : ti.TypeName));

                    sb.AppendLine($"import {{ {reflectionList} }} from \"{import.ImportPath}\";");
                }

                // CRITICAL: Always emit namespace import for ALL value imports (not just non-reflection)
                // Namespace imports are required for accessing types inside namespace blocks
                if (valueImports.Count > 0)
                {
                    sb.AppendLine($"import * as {import.NamespaceAlias} from \"{import.ImportPath}\";");
                }

                // Emit type-only imports (for type annotations - these work in namespaces)
                if (typeOnlyImports.Count > 0)
                {
                    var typeOnlyList = string.Join(", ", typeOnlyImports
                        .OrderBy(ti => ti.TypeName)
                        .Select(ti => ti.Alias != null ? $"{ti.TypeName} as {ti.Alias}" : ti.TypeName));

                    sb.AppendLine($"import type {{ {typeOnlyList} }} from \"{import.ImportPath}\";");
                }
            }

            sb.AppendLine(); // Blank line after imports
        }

        // ROOT NAMESPACE FIX: Types in root namespace (empty name) are emitted at module level
        // No namespace wrapper for root - types are module-level declarations
        var isRoot = nsOrder.Namespace.IsRoot;
        var indent = isRoot ? "" : "    ";

        // PHASE-1 FIX: Collect types for top-level re-export shim (TS2305/TS2315 fix)
        // Non-root namespaces need top-level re-exports so imports can use named imports
        // Store TypeSymbol to preserve generic parameter information
        var topLevelExports = new List<TypeSymbol>();

        // TS2315 FIX: Track types that had generics in CLR but were emitted without them
        // (e.g., static classes with generic static members - TypeScript doesn't support class-level generics for static-only classes)
        // This prevents convenience export aliases from referencing them with type parameters
        var typesWithoutGenerics = new HashSet<string>();

        if (!isRoot)
        {
            // Non-root: Wrap in namespace declaration
            sb.AppendLine($"export namespace {nsOrder.Namespace.Name} {{");
        }

        // Emit types in order (PUBLIC ONLY - internal types should not appear in .d.ts)
        foreach (var typeOrder in nsOrder.OrderedTypes.Where(to => ShouldEmit(to.Type)))
        {
            // Check if type has explicit views (attached by ViewPlanner)
            var views = typeOrder.Type.ExplicitViews;
            var hasViews = views.Length > 0 && (typeOrder.Type.Kind == Model.Symbols.TypeKind.Class || typeOrder.Type.Kind == Model.Symbols.TypeKind.Struct);

            if (hasViews)
            {
                // Emit class with $instance suffix - PUBLIC TYPES GET export KEYWORD
                var instanceClass = ClassPrinter.PrintInstance(typeOrder.Type, resolver, ctx, graph, bindingsProvider);
                var indentedInstance = Indent(instanceClass, indent);

                // PUBLIC TYPES: Always export (both root and namespaces)
                sb.Append("export ");
                sb.AppendLine(indentedInstance);
                sb.AppendLine();

                // Emit companion views interface - PUBLIC TYPES GET export KEYWORD
                var viewsInterface = EmitCompanionViewsInterface(typeOrder.Type, views, resolver, ctx);
                var indentedViews = Indent(viewsInterface, indent);

                // PUBLIC TYPES: Always export (both root and namespaces)
                sb.Append("export ");
                sb.AppendLine(indentedViews);
                sb.AppendLine();

                // Emit intersection type alias (already has export in the returned string)
                var typeAlias = EmitIntersectionTypeAlias(typeOrder.Type, resolver, ctx);
                var indentedAlias = Indent(typeAlias, indent);

                // Type alias already includes "export" keyword
                sb.AppendLine(indentedAlias);
                sb.AppendLine();

                // PHASE-1 FIX: Collect type for top-level re-export
                // For views pattern: export the final type alias
                if (!isRoot)
                    topLevelExports.Add(typeOrder.Type);
            }
            else
            {
                // Normal emission (no views) - PUBLIC TYPES GET export KEYWORD
                var typeDecl = ClassPrinter.Print(typeOrder.Type, resolver, ctx, graph, typesWithoutGenerics, bindingsProvider);
                var indented = Indent(typeDecl, indent);

                // PUBLIC TYPES: Always export (both root and namespaces)
                sb.Append("export ");
                sb.AppendLine(indented);
                sb.AppendLine();

                // PHASE-1 FIX: Collect type for top-level re-export
                if (!isRoot)
                    topLevelExports.Add(typeOrder.Type);
            }
        }

        if (!isRoot)
        {
            // Close namespace wrapper
            sb.AppendLine("}");
            sb.AppendLine();

            // PHASE-1 FIX: Emit top-level re-exports for TS2305/TS2315 fix
            // This allows: import type { Object_ } from "../../System/internal/index"
            // Instead of:  import type { System } from "../../System/internal/index"
            // Once verified working, we can remove namespace wrapper entirely (PHASE-2)
            if (topLevelExports.Count > 0)
            {
                sb.AppendLine("// Top-level re-exports (transitional shim for import compatibility)");
                sb.AppendLine($"// These allow named imports instead of namespace imports");

                // Sort by type name for stable output
                var sortedExports = topLevelExports.OrderBy(t => ctx.Renamer.GetFinalTypeName(t)).ToList();

                // INTERNAL CONSTRAINTS: Emit type aliases with generic constraints preserved
                foreach (var type in sortedExports)
                {
                    // STEP 1 RE-EXPORT FIX (Updated for views):
                    // - LHS (aliasName): Use bare stem for user-friendly name (e.g., "Console", "List_1")
                    // - RHS (rhsExpression): Depends on whether type has views:
                    //   * WITH views: Use alias (Module_ = Module_$instance & __Module_$views)
                    //   * WITHOUT views: Use instance name (Console$instance)
                    var typeName = ctx.Renamer.GetFinalTypeName(type);  // Bare stem for alias

                    // TS2315 FIX: Skip convenience exports for types that lost their generics during emission
                    // These are static classes with generic static members - emitted as non-generic classes
                    if (typesWithoutGenerics.Contains(typeName))
                    {
                        ctx.Log("TS2315Fix", $"Skipping convenience export for {typeName} (type was emitted without generics)");
                        continue;
                    }

                    // TS2416 FIX: Determine which name to reference based on views
                    // Types WITH views have an alias inside the namespace (Foo = Foo$instance & __Foo$views)
                    // Types WITHOUT views only have the instance type (Foo$instance)
                    var hasViews = type.ExplicitViews.Length > 0 &&
                                   (type.Kind == Model.Symbols.TypeKind.Class || type.Kind == Model.Symbols.TypeKind.Struct);
                    var rhsTypeName = hasViews ? typeName : ctx.Renamer.GetInstanceTypeName(type);

                    // STEP A.2 VALIDATION: Re-export correctness assertions
                    // Ensures views-based re-export logic is working correctly
                    if (hasViews && rhsTypeName.Contains("$instance"))
                    {
                        throw new InvalidOperationException(
                            $"[RE-EXPORT BUG] Type {type.ClrFullName} has views but re-export uses instance name '{rhsTypeName}' instead of alias '{typeName}'");
                    }
                    if (!hasViews && !rhsTypeName.Contains("$instance") && (type.Kind == Model.Symbols.TypeKind.Class || type.Kind == Model.Symbols.TypeKind.Struct))
                    {
                        throw new InvalidOperationException(
                            $"[RE-EXPORT BUG] Type {type.ClrFullName} has no views but re-export uses alias '{rhsTypeName}' instead of instance name");
                    }

                    // Emit: export type Foo<T extends IFoo> = Namespace.Foo<T>;
                    //   or: export type Foo<T extends IFoo> = Namespace.Foo$instance<T>;
                    AliasEmit.EmitGenericAlias(
                        sb,
                        aliasName: typeName,
                        sourceType: type,
                        rhsExpression: $"{nsOrder.Namespace.Name}.{rhsTypeName}",
                        resolver,
                        ctx,
                        withConstraints: true); // Internal convenience exports preserve constraints
                }
            }
        }

        return sb.ToString();
    }

    /// <summary>
    /// INTERNAL CONSTRAINTS: Generates generic type parameters WITH constraints for internal convenience exports.
    /// Mirrors the facade constraint propagation logic to fix TS2344 errors in module-level type aliases.
    /// </summary>
    private static string GenerateTypeParametersWithConstraints(
        Model.Symbols.TypeSymbol sourceType,
        TypeNameResolver resolver,
        BuildContext ctx)
    {
        var gps = sourceType.GenericParameters;
        if (gps.Length == 0)
            return string.Empty;

        var parts = new List<string>(gps.Length);

        foreach (var gp in gps)
        {
            // Collect type constraints (interfaces/classes)
            // Skip C# special constraints (struct, class, new()) as TypeScript can't express them
            var typeConstraints = gp.Constraints
                .Where(c => c is not null && !IsSpecialConstraint(c))
                .ToList();

            if (typeConstraints.Count == 0)
            {
                // No constraints: just the parameter name
                parts.Add(gp.Name);
            }
            else
            {
                // Print each constraint using TypeRefPrinter (handles CLROf, imports, etc.)
                var constraintStrings = typeConstraints
                    .Select(c => Printers.TypeRefPrinter.Print(c, resolver, ctx))
                    .ToArray();

                // Join multiple constraints with & (intersection type)
                var constraintList = string.Join(" & ", constraintStrings);
                parts.Add($"{gp.Name} extends {constraintList}");
            }
        }

        return $"<{string.Join(", ", parts)}>";
    }

    /// <summary>
    /// Check if a constraint is a C# special constraint (struct, class, new()).
    /// These don't translate to TypeScript and should be filtered out.
    /// </summary>
    private static bool IsSpecialConstraint(Model.Types.TypeReference constraint)
    {
        // Special constraints (struct, class, new()) are not in GenericParameter.Constraints
        // They're represented by separate flags in the model
        // This method is here for future-proofing in case the model changes
        return false;
    }

    private static void EmitBrandedPrimitives(StringBuilder sb)
    {
        sb.AppendLine("// Branded primitive types for CLR numeric types");

        sb.AppendLine("// Primitives implement IEquatable and IComparable to satisfy generic constraints");
        sb.AppendLine("// Note: Using 'any' in interface type parameters to avoid circular reference (TS2456)");

        // Use inline type imports to reference interfaces from System namespace
        // Format: import("relative-path").InterfaceName
        // IMPORTANT: Use 'any' as type parameter to avoid circular references
        // TypeScript limitation: `type byte = ... & IEquatable_1<byte>` causes TS2456
        const string IEq = "import(\"../../System/internal/index\").IEquatable_1<any>";
        const string ICmp = "import(\"../../System/internal/index\").IComparable_1<any>";

        // Integer types
        sb.AppendLine($"export type sbyte = number & {{ __brand: \"sbyte\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type byte = number & {{ __brand: \"byte\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type short = number & {{ __brand: \"short\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type ushort = number & {{ __brand: \"ushort\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type int = number & {{ __brand: \"int\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type uint = number & {{ __brand: \"uint\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type long = number & {{ __brand: \"long\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type ulong = number & {{ __brand: \"ulong\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type int128 = number & {{ __brand: \"int128\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type uint128 = number & {{ __brand: \"uint128\" }} & {IEq} & {ICmp};");

        // Floating-point types
        sb.AppendLine($"export type half = number & {{ __brand: \"half\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type float = number & {{ __brand: \"float\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type double = number & {{ __brand: \"double\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type decimal = number & {{ __brand: \"decimal\" }} & {IEq} & {ICmp};");

        // Native-sized integers
        sb.AppendLine($"export type nint = number & {{ __brand: \"nint\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type nuint = number & {{ __brand: \"nuint\" }} & {IEq} & {ICmp};");

        // Character type
        sb.AppendLine($"export type char = string & {{ __brand: \"char\" }} & {IEq} & {ICmp};");

        sb.AppendLine();

        // CLROf<T> - Primitive Lifting Utility
        // CRITICAL: Uses PrimitiveLift.Rules as single source of truth (PG_GENERIC_PRIM_LIFT_001)
        sb.AppendLine("// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints");
        sb.AppendLine("// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints");
        sb.AppendLine("// Value positions (parameters, return types) use lowercase primitives for ergonomics");
        sb.AppendLine("export type CLROf<T> =");

        // Generate conditional type branches from PrimitiveLift.Rules
        foreach (var (tsName, _, clrSimpleName) in PrimitiveLift.Rules)
        {
            sb.AppendLine($"    T extends {tsName} ? import(\"../../System/internal/index\").{clrSimpleName} :");
        }

        sb.AppendLine("    T; // Identity fallback for non-primitive types");
        sb.AppendLine();
    }

    private static string EmitCompanionViewsInterface(TypeSymbol type, ImmutableArray<Shape.ViewPlanner.ExplicitView> views, TypeNameResolver resolver, BuildContext ctx)
    {
        var sb = new StringBuilder();

        // Get final type name
        var finalName = ctx.Renamer.GetFinalTypeName(type);

        // Companion interface: __TypeName$views<...>
        sb.Append($"interface __{finalName}$views");

        // Generic parameters
        if (type.GenericParameters.Length > 0)
        {
            sb.Append('<');
            sb.Append(string.Join(", ", type.GenericParameters.Select(gp => gp.Name)));
            sb.Append('>');
        }

        sb.AppendLine(" {");

        // Emit view properties
        foreach (var view in views)
        {
            sb.Append("    readonly ");
            sb.Append(view.ViewPropertyName);
            sb.Append(": ");

            // FIX D: Match view's interface reference to type's actual interface implementation
            // to get correct type arguments (fixes generic "T" leaks in view interfaces)
            var matchedInterface = FindMatchingInterface(type, view.InterfaceReference);
            var interfaceToEmit = matchedInterface ?? view.InterfaceReference;

            // TS2304 FIX: View interfaces need namespace qualification
            // Some view interfaces (like IEnumerable) are transitively implemented and not in
            // ValueImportQualifiedNames, so we need to manually qualify cross-namespace types
            var viewTypeName = QualifyViewInterface(interfaceToEmit, type.Namespace, resolver, ctx);
            sb.Append(viewTypeName);
            sb.AppendLine(";");
        }

        // TS2344 FIX: Add structural method bridges for numeric interface constraints
        // TypeScript uses structural typing - interfaces require PascalCase methods
        // but instance classes use camelCase. Add PascalCase methods to satisfy constraints.
        var numericInterfaces = GetNumericInterfaceSet(views);
        if (numericInterfaces != null)
        {
            sb.AppendLine();
            sb.AppendLine("    // Structural method bridges for numeric interface constraints");
            EmitNumericStructuralMethods(sb, type, numericInterfaces, resolver, ctx);
        }

        sb.Append("}");

        return sb.ToString();
    }

    /// <summary>
    /// Get the set of numeric interfaces that require structural method bridges.
    /// Returns null if no numeric interfaces are implemented.
    /// </summary>
    private static HashSet<string>? GetNumericInterfaceSet(ImmutableArray<Shape.ViewPlanner.ExplicitView> views)
    {
        HashSet<string>? interfaces = null;

        foreach (var view in views)
        {
            if (view.InterfaceReference is Model.Types.NamedTypeReference named)
            {
                var interfaceName = named.FullName;

                // Track which specific numeric interfaces are implemented
                if (interfaceName.Contains("System.Numerics.INumber`1") ||
                    interfaceName.Contains("System.Numerics.IBinaryInteger`1") ||
                    interfaceName.Contains("System.Numerics.IFloatingPoint`1") ||
                    interfaceName.Contains("System.Numerics.INumberBase`1") ||
                    interfaceName.Contains("System.Numerics.IRootFunctions`1") ||
                    interfaceName.Contains("System.Numerics.ITrigonometricFunctions`1") ||
                    interfaceName.Contains("System.IEquatable`1") ||
                    interfaceName.Contains("System.IComparable"))
                {
                    interfaces ??= new HashSet<string>();

                    // Normalize to generic base name for easier checking
                    if (interfaceName.Contains("System.Numerics.INumber`1"))
                        interfaces.Add("INumber");
                    if (interfaceName.Contains("System.Numerics.IBinaryInteger`1"))
                        interfaces.Add("IBinaryInteger");
                    if (interfaceName.Contains("System.Numerics.IFloatingPoint`1"))
                        interfaces.Add("IFloatingPoint");
                    if (interfaceName.Contains("System.Numerics.INumberBase`1"))
                        interfaces.Add("INumberBase");
                    if (interfaceName.Contains("System.Numerics.IRootFunctions`1"))
                        interfaces.Add("IRootFunctions");
                    if (interfaceName.Contains("System.Numerics.ITrigonometricFunctions`1"))
                        interfaces.Add("ITrigonometricFunctions");
                    if (interfaceName.Contains("System.IEquatable`1"))
                        interfaces.Add("IEquatable");
                    if (interfaceName.Contains("System.IComparable"))
                        interfaces.Add("IComparable");
                }
            }
        }

        return interfaces;
    }

    /// <summary>
    /// Emit structural method bridges to satisfy numeric interface constraints.
    /// These methods use PascalCase (matching C# interface definitions) while instance
    /// methods use camelCase. This satisfies TypeScript's structural type checking.
    /// Only emits methods for the specific interfaces actually implemented.
    /// </summary>
    private static void EmitNumericStructuralMethods(
        StringBuilder sb,
        TypeSymbol type,
        HashSet<string> numericInterfaces,
        TypeNameResolver resolver,
        BuildContext ctx)
    {
        // Get the actual type name with generic parameters for use in signatures
        var typeName = ctx.Renamer.GetFinalTypeName(type);
        if (type.GenericParameters.Length > 0)
        {
            typeName += $"<{string.Join(", ", type.GenericParameters.Select(gp => gp.Name))}>";
        }

        // Determine if we're in System namespace (can use simple names)
        var inSystemNamespace = type.Namespace == "System";

        // Helper to get qualified type name
        string Qualified(string simpleName)
        {
            if (inSystemNamespace)
                return simpleName;
            else
                return $"import(\"../../System/internal/index\").{simpleName}";
        }

        // IEquatable<T>.Equals
        if (numericInterfaces.Contains("IEquatable"))
        {
            sb.AppendLine($"    Equals(other: {typeName}): boolean;");
        }

        // IComparable.CompareTo
        if (numericInterfaces.Contains("IComparable"))
        {
            sb.AppendLine("    CompareTo(obj: any): int;");
        }

        // INumberBase<TSelf>, INumber<TSelf>, IBinaryInteger<TSelf>, IFloatingPoint<TSelf>, etc.
        // All require ToString and TryFormat
        if (numericInterfaces.Contains("INumberBase") ||
            numericInterfaces.Contains("INumber") ||
            numericInterfaces.Contains("IBinaryInteger") ||
            numericInterfaces.Contains("IFloatingPoint") ||
            numericInterfaces.Contains("IRootFunctions") ||
            numericInterfaces.Contains("ITrigonometricFunctions"))
        {
            sb.AppendLine($"    ToString(format: string, formatProvider: {Qualified("IFormatProvider")}): string;");
            // TSByRef is from _support/types, so never qualify it
            sb.AppendLine($"    TryFormat(destination: {Qualified("Span_1")}<{Qualified("CLROf")}<string>>, charsWritten: {{ value: TSByRef<int> }}, format: {Qualified("ReadOnlySpan_1")}<{Qualified("CLROf")}<string>>, provider: {Qualified("IFormatProvider")}): boolean;");
        }

        // IBinaryInteger<TSelf> - GetByteCount
        if (numericInterfaces.Contains("IBinaryInteger"))
        {
            sb.AppendLine("    GetByteCount(): int;");
        }

        // IFloatingPoint<TSelf> - GetExponentByteCount, GetExponentShortestBitLength
        if (numericInterfaces.Contains("IFloatingPoint"))
        {
            sb.AppendLine("    GetExponentByteCount(): int;");
            sb.AppendLine("    GetExponentShortestBitLength(): int;");
        }
    }

    /// <summary>
    /// TS2304 FIX: Qualify view interface types with namespace alias if cross-namespace.
    /// View interfaces that are transitively implemented (not directly in implements clause)
    /// don't get added to ValueImportQualifiedNames, so we need manual qualification.
    /// </summary>
    private static string QualifyViewInterface(
        Model.Types.TypeReference interfaceRef,
        string currentNamespace,
        TypeNameResolver resolver,
        BuildContext ctx)
    {
        // Try to get the base type name first
        var baseName = Printers.TypeRefPrinter.Print(interfaceRef, resolver, ctx);

        // If it's a NamedTypeReference, check if it's cross-namespace
        if (interfaceRef is Model.Types.NamedTypeReference named)
        {
            // Extract namespace from CLR full name
            var fullName = named.FullName;
            var commaIndex = fullName.IndexOf(',');
            if (commaIndex >= 0)
            {
                fullName = fullName.Substring(0, commaIndex).Trim();
            }

            var interfaceNamespace = fullName.Contains('.')
                ? fullName.Substring(0, fullName.LastIndexOf('.'))
                : "";

            // If cross-namespace and not already qualified (doesn't contain '.'), qualify it
            if (!string.IsNullOrEmpty(interfaceNamespace) &&
                interfaceNamespace != currentNamespace &&
                !baseName.Contains('.'))
            {
                // Generate namespace alias (e.g., "System.Collections" → "System_Collections_Internal")
                var namespaceAlias = interfaceNamespace.Replace('.', '_') + "_Internal";
                var qualifiedName = $"{namespaceAlias}.{interfaceNamespace}.{baseName}";
                return qualifiedName;
            }
        }

        return baseName;
    }

    /// <summary>
    /// FIX D: Find the matching interface in type.Interfaces that corresponds to the view's interface reference.
    /// Returns the matched interface with correct type arguments, or null if not found.
    /// </summary>
    private static TypeReference? FindMatchingInterface(TypeSymbol type, TypeReference viewInterfaceRef)
    {
        // Get the base name without type arguments for matching
        var viewBaseName = GetInterfaceBaseName(viewInterfaceRef);

        foreach (var implementedInterface in type.Interfaces)
        {
            var implBaseName = GetInterfaceBaseName(implementedInterface);

            // Match by base name (e.g., "IEnumerator_1" matches)
            if (viewBaseName == implBaseName)
            {
                return implementedInterface;
            }
        }

        return null;
    }

    /// <summary>
    /// Get the base name of an interface (without type arguments) for matching.
    /// Examples: "IEnumerator`1" -> "IEnumerator`1", "System.Collections.Generic.IEnumerator`1" -> "IEnumerator`1"
    /// </summary>
    private static string GetInterfaceBaseName(TypeReference typeRef)
    {
        return typeRef switch
        {
            NamedTypeReference named => named.Name,  // Just the name, e.g., "IEnumerator`1"
            NestedTypeReference nested => nested.NestedName,
            _ => typeRef.ToString() ?? ""
        };
    }

    private static string EmitIntersectionTypeAlias(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
    {
        var sb = new StringBuilder();

        // Get final type name
        var finalName = ctx.Renamer.GetFinalTypeName(type);

        // VIEW COMPOSITION CONSTRAINTS: Type alias with constraints on LHS, plain args on RHS
        // export type TypeName<T extends IFoo> = TypeName$instance<T> & __TypeName$views<T>

        // Build RHS: both $instance and $views need type arguments
        var typeArgs = AliasEmit.GenerateTypeArguments(type);
        var rhsExpression = $"{finalName}$instance{typeArgs} & __{finalName}$views{typeArgs}";

        // Emit the alias with constraints on LHS
        // Note: We pass the complete RHS (including type args), so we use the manual emission
        sb.Append("export type ");
        sb.Append(finalName);

        var typeParamsLHS = AliasEmit.GenerateTypeParametersWithConstraints(type, resolver, ctx);
        sb.Append(typeParamsLHS);

        sb.Append(" = ");
        sb.Append(rhsExpression);
        sb.AppendLine(";");

        return sb.ToString();
    }

    private static string Indent(string text, string indentation)
    {
        var lines = text.Split('\n').Select(line => string.IsNullOrWhiteSpace(line) ? line : indentation + line);
        return string.Join("\n", lines);
    }

    /// <summary>
    /// Check if namespace contains any pointer or byref types that require support type markers.
    /// Scans all public types and their members for PointerTypeReference or ByRefTypeReference.
    /// </summary>
    private static bool NamespaceUsesSupportTypes(NamespaceSymbol ns)
    {
        foreach (var type in ns.Types.Where(t => t.Accessibility == Accessibility.Public))
        {
            // TS2304 FIX: Check constructors for unsafe types
            foreach (var ctor in type.Members.Constructors)
            {
                // Constructors are always on class surface
                foreach (var param in ctor.Parameters)
                {
                    if (ContainsUnsafeType(param.Type))
                        return true;
                }
            }

            // Check methods (only those actually emitted to class/static surface)
            foreach (var method in type.Members.Methods)
            {
                // Only check methods on class/static surface (skip ViewOnly)
                if (method.EmitScope != EmitScope.ClassSurface && method.EmitScope != EmitScope.StaticSurface)
                    continue;

                // Check return type
                if (ContainsUnsafeType(method.ReturnType))
                    return true;

                // Check parameters
                foreach (var param in method.Parameters)
                {
                    if (ContainsUnsafeType(param.Type))
                        return true;
                }
            }

            // Check properties (only those on class/static surface)
            foreach (var prop in type.Members.Properties)
            {
                if (prop.EmitScope != EmitScope.ClassSurface && prop.EmitScope != EmitScope.StaticSurface)
                    continue;

                if (ContainsUnsafeType(prop.PropertyType))
                    return true;
            }

            // Check fields (only those on class/static surface)
            foreach (var field in type.Members.Fields)
            {
                if (field.EmitScope != EmitScope.ClassSurface && field.EmitScope != EmitScope.StaticSurface)
                    continue;

                if (ContainsUnsafeType(field.FieldType))
                    return true;
            }

            // Check events (only those on class/static surface)
            foreach (var evt in type.Members.Events)
            {
                if (evt.EmitScope != EmitScope.ClassSurface && evt.EmitScope != EmitScope.StaticSurface)
                    continue;

                if (ContainsUnsafeType(evt.EventHandlerType))
                    return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Recursively check if a type reference contains pointers or byrefs.
    /// </summary>
    private static bool ContainsUnsafeType(Model.Types.TypeReference typeRef)
    {
        return typeRef switch
        {
            Model.Types.PointerTypeReference => true,
            Model.Types.ByRefTypeReference => true,
            Model.Types.ArrayTypeReference arr => ContainsUnsafeType(arr.ElementType),
            Model.Types.NamedTypeReference named => named.TypeArguments.Any(ContainsUnsafeType),
            Model.Types.NestedTypeReference nested => ContainsUnsafeType(nested.FullReference),
            _ => false
        };
    }

}

using System.Text;
using tsbindgen.SinglePhase.Emit.Printers;
using tsbindgen.SinglePhase.Model;
using tsbindgen.SinglePhase.Plan;

namespace tsbindgen.SinglePhase.Emit;

/// <summary>
/// Emits internal/index.d.ts files for each namespace.
/// Uses EmitOrder to generate declarations in deterministic order.
/// Orchestrates ClassPrinter, MethodPrinter, TypeRefPrinter.
/// </summary>
public static class InternalIndexEmitter
{
    public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
    {
        ctx.Log("InternalIndexEmitter: Generating TypeScript declarations...");

        var emittedCount = 0;

        // Process each namespace in order
        foreach (var nsOrder in plan.EmissionOrder.Namespaces)
        {
            var ns = nsOrder.Namespace;
            ctx.Log($"  Emitting namespace: {ns.Name}");

            // Generate .d.ts content
            var content = GenerateNamespaceDeclaration(ctx, nsOrder);

            // Write to file: output/Namespace.Name/internal/index.d.ts
            var namespacePath = Path.Combine(outputDirectory, ns.Name);
            var internalPath = Path.Combine(namespacePath, "internal");
            Directory.CreateDirectory(internalPath);

            var outputFile = Path.Combine(internalPath, "index.d.ts");
            File.WriteAllText(outputFile, content);

            ctx.Log($"    â†’ {outputFile}");
            emittedCount++;
        }

        ctx.Log($"InternalIndexEmitter: Generated {emittedCount} declaration files");
    }

    private static string GenerateNamespaceDeclaration(BuildContext ctx, NamespaceEmitOrder nsOrder)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// Generated by tsbindgen - Single-Phase Architecture");
        sb.AppendLine($"// Namespace: {nsOrder.Namespace.Name}");
        sb.AppendLine($"// Assembly: {string.Join(", ", nsOrder.Namespace.ContributingAssemblies)}");
        sb.AppendLine();

        // Branded primitive types (if this is System namespace)
        if (nsOrder.Namespace.Name == "System")
        {
            EmitBrandedPrimitives(sb);
        }

        // Namespace declaration
        sb.AppendLine($"export namespace {nsOrder.Namespace.Name} {{");

        // Emit types in order
        foreach (var typeOrder in nsOrder.OrderedTypes)
        {
            var typeDecl = ClassPrinter.Print(typeOrder.Type, ctx);

            // Indent each line
            var indentedLines = typeDecl.Split('\n')
                .Select(line => string.IsNullOrWhiteSpace(line) ? line : "    " + line);

            sb.AppendLine(string.Join("\n", indentedLines));
            sb.AppendLine();
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void EmitBrandedPrimitives(StringBuilder sb)
    {
        sb.AppendLine("// Branded primitive types for CLR numeric types");
        sb.AppendLine("export type sbyte = number & { __brand: \"sbyte\" };");
        sb.AppendLine("export type byte = number & { __brand: \"byte\" };");
        sb.AppendLine("export type short = number & { __brand: \"short\" };");
        sb.AppendLine("export type ushort = number & { __brand: \"ushort\" };");
        sb.AppendLine("export type int = number & { __brand: \"int\" };");
        sb.AppendLine("export type uint = number & { __brand: \"uint\" };");
        sb.AppendLine("export type long = number & { __brand: \"long\" };");
        sb.AppendLine("export type ulong = number & { __brand: \"ulong\" };");
        sb.AppendLine("export type float = number & { __brand: \"float\" };");
        sb.AppendLine("export type double = number & { __brand: \"double\" };");
        sb.AppendLine("export type decimal = number & { __brand: \"decimal\" };");
        sb.AppendLine("export type nint = number & { __brand: \"nint\" };");
        sb.AppendLine("export type nuint = number & { __brand: \"nuint\" };");
        sb.AppendLine();
    }
}

using System.Text;
using tsbindgen.Analysis;
using tsbindgen.Emit.Printers;
using tsbindgen.Model.Symbols.MemberSymbols;
using tsbindgen.Renaming;
using tsbindgen.Model;

namespace tsbindgen.Emit;

/// <summary>
/// Emits extension method bucket interfaces to internal/extensions/index.d.ts.
/// Each bucket contains all extension methods for a specific target type.
/// Example: __Ext_IEnumerable_1&lt;T&gt; contains Select, Where, etc.
/// </summary>
public static class ExtensionsEmitter
{
    /// <summary>
    /// Emit the internal/extensions/index.d.ts file containing all bucket interfaces.
    /// </summary>
    /// <param name="ctx">Build context</param>
    /// <param name="plan">Extension methods plan with all buckets</param>
    /// <param name="graph">Symbol graph for type resolution</param>
    /// <param name="outputDirectory">Root output directory</param>
    public static void Emit(BuildContext ctx, ExtensionMethodsPlan plan, SymbolGraph graph, string outputDirectory)
    {
        if (plan.Buckets.Length == 0)
        {
            ctx.Log("ExtensionsEmitter", "No extension methods found - skipping extensions file");
            return;
        }

        ctx.Log("ExtensionsEmitter", $"Emitting extension method buckets: {plan.Buckets.Length} buckets");

        // Create internal/extensions directory
        var extensionsDir = Path.Combine(outputDirectory, "internal", "extensions");
        Directory.CreateDirectory(extensionsDir);

        // Generate file content
        var content = GenerateExtensionsFile(ctx, plan, graph);

        // Write file
        var filePath = Path.Combine(extensionsDir, "index.d.ts");
        File.WriteAllText(filePath, content);

        ctx.Log("ExtensionsEmitter", $"Wrote {filePath}");
    }

    /// <summary>
    /// Generate the complete extensions file content.
    /// </summary>
    private static string GenerateExtensionsFile(BuildContext ctx, ExtensionMethodsPlan plan, SymbolGraph graph)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// Generated by tsbindgen - Extension Method Buckets");
        sb.AppendLine("// This file contains bucket interfaces for C# extension methods.");
        sb.AppendLine("// Each __Ext_* interface groups all extension methods for a specific target type.");
        sb.AppendLine();

        // Collect all namespaces used in extension method signatures
        var namespacesUsed = new HashSet<string>();
        foreach (var bucket in plan.Buckets)
        {
            // Add the target type's namespace (needed for ExtensionMethods<TShape> helper)
            namespacesUsed.Add(bucket.TargetType.Namespace);

            foreach (var method in bucket.Methods)
            {
                // Collect from return type
                CollectNamespaces(method.ReturnType, namespacesUsed, graph);

                // Collect from parameters (skip first 'this' parameter)
                foreach (var param in method.Parameters.Skip(1))
                {
                    CollectNamespaces(param.Type, namespacesUsed, graph);
                }
            }
        }

        // Generate namespace imports
        // Extension methods file is at internal/extensions/index.d.ts
        // Namespaces are at ../../{Namespace}/internal/index.js
        if (namespacesUsed.Count > 0)
        {
            sb.AppendLine("// Import namespace modules for cross-namespace type references");
            foreach (var ns in namespacesUsed.OrderBy(n => n))
            {
                var namespaceAlias = ns.Replace('.', '_');
                var importPath = $"../../{ns}/internal/index.js";
                sb.AppendLine($"import * as {namespaceAlias} from \"{importPath}\";");
            }
            sb.AppendLine();
        }

        // Import branded primitive types from @tsonic/types
        sb.AppendLine("// Import branded primitive types");
        sb.AppendLine("import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';");
        sb.AppendLine();

        // Import CLROf utility type from System namespace (needed for generic constraints)
        sb.AppendLine("// Import CLROf utility for primitive type lifting");
        sb.AppendLine("import type { CLROf } from '../../System/internal/index.js';");
        sb.AppendLine();

        // Import TSByRef and TSUnsafePointer support types (needed for ref/out parameters and pointers)
        sb.AppendLine("// Import unsafe type markers");
        sb.AppendLine("import type { TSByRef, TSUnsafePointer } from '../../_support/types.js';");
        sb.AppendLine();

        // Create TypeNameResolver for this file
        // Extension methods file needs all cross-namespace types to be fully qualified
        // Use a dummy namespace "internal.extensions" and enable facade mode
        // This triggers cross-namespace qualification for all type references
        var resolver = new TypeNameResolver(ctx, graph, importPlan: null, currentNamespace: "internal.extensions", facadeMode: true);

        // Emit each bucket interface
        foreach (var bucket in plan.Buckets)
        {
            EmitBucketInterface(sb, ctx, bucket, resolver);
            sb.AppendLine();
        }

        // Emit ExtensionMethods<TShape> helper type
        EmitExtensionMethodsHelper(sb, plan, graph);

        return sb.ToString();
    }

    /// <summary>
    /// Recursively collect all namespaces used in a type reference.
    /// </summary>
    private static void CollectNamespaces(Model.Types.TypeReference typeRef, HashSet<string> namespaces, SymbolGraph graph)
    {
        switch (typeRef)
        {
            case Model.Types.NamedTypeReference named:
                // Look up the type in the graph
                if (graph.TypeIndex.TryGetValue(named.FullName, out var typeSymbol))
                {
                    // Add the namespace
                    namespaces.Add(typeSymbol.Namespace);
                }

                // Collect from type arguments
                foreach (var arg in named.TypeArguments)
                {
                    CollectNamespaces(arg, namespaces, graph);
                }
                break;

            case Model.Types.ArrayTypeReference array:
                CollectNamespaces(array.ElementType, namespaces, graph);
                break;

            case Model.Types.ByRefTypeReference byRef:
                CollectNamespaces(byRef.ReferencedType, namespaces, graph);
                break;

            case Model.Types.PointerTypeReference pointer:
                CollectNamespaces(pointer.PointeeType, namespaces, graph);
                break;

            case Model.Types.NestedTypeReference nested:
                CollectNamespaces(nested.FullReference, namespaces, graph);
                break;
        }
    }

    /// <summary>
    /// Check if any method in the bucket requires IEquatable constraint for a type parameter.
    /// This happens when methods have "where T : IEquatable&lt;T&gt;" constraints.
    /// </summary>
    private static bool BucketNeedsIEquatableConstraint(ExtensionBucketPlan bucket, string paramName)
    {
        foreach (var method in bucket.Methods)
        {
            // Check if any of the method's generic parameters that match paramName have IEquatable constraint
            foreach (var genericParam in method.GenericParameters)
            {
                if (genericParam.Name == paramName)
                {
                    // Check constraints on this generic parameter
                    if (genericParam.Constraints != null)
                    {
                        foreach (var constraint in genericParam.Constraints)
                        {
                            // Check if constraint is IEquatable<T>
                            if (constraint is Model.Types.NamedTypeReference namedConstraint &&
                                namedConstraint.FullName.Contains("IEquatable"))
                            {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    /// <summary>
    /// Emit a single bucket interface.
    /// </summary>
    private static void EmitBucketInterface(StringBuilder sb, BuildContext ctx, ExtensionBucketPlan bucket, TypeNameResolver resolver)
    {
        var targetType = bucket.TargetType;

        // Interface declaration with generic parameters
        sb.Append($"export interface {bucket.BucketInterfaceName}");

        // Add generic parameters if target type is generic
        if (targetType.GenericParameters.Length > 0)
        {
            sb.Append('<');
            var genericParams = new List<string>();
            foreach (var param in targetType.GenericParameters)
            {
                // Check if any method in this bucket requires IEquatable constraint for this parameter
                var needsIEquatable = BucketNeedsIEquatableConstraint(bucket, param.Name);

                if (needsIEquatable)
                {
                    // Add IEquatable constraint: T extends IEquatable_1<T>
                    genericParams.Add($"{param.Name} extends System.IEquatable_1<{param.Name}>");
                }
                else
                {
                    // No constraint needed
                    genericParams.Add(param.Name);
                }
            }
            sb.Append(string.Join(", ", genericParams));
            sb.Append('>');
        }

        sb.AppendLine(" {");

        // Emit methods
        foreach (var method in bucket.Methods)
        {
            EmitExtensionMethod(sb, ctx, method, resolver, targetType.GenericParameters);
        }

        sb.AppendLine("}");
    }

    /// <summary>
    /// Emit an extension method as an instance method in the bucket interface.
    /// Drops the first 'this' parameter and emits remaining parameters.
    /// Collapses method-level generics that match the target type's generics.
    /// </summary>
    private static void EmitExtensionMethod(
        StringBuilder sb,
        BuildContext ctx,
        MethodSymbol method,
        TypeNameResolver resolver,
        IReadOnlyList<Model.Symbols.GenericParameterSymbol> targetGenericParameters)
    {
        // Skip the first parameter (the 'this' parameter) for extension methods
        var instanceParams = method.Parameters.Skip(1).ToArray();

        sb.Append("  ");

        // Method name (use TsEmitName)
        var methodName = !string.IsNullOrEmpty(method.TsEmitName) ? method.TsEmitName : method.ClrName;
        sb.Append(methodName);

        // Determine which method generic parameters to emit
        // Collapse method generics that match target type generics (by name)
        var targetGenericNames = new HashSet<string>(targetGenericParameters.Select(p => p.Name));
        var methodGenericsToEmit = method.GenericParameters
            .Where(p => !targetGenericNames.Contains(p.Name))
            .ToList();

        // Build allowed type parameter names for TypeRefPrinter
        // Include both target generics AND method generics (whether emitted or collapsed)
        var allowedTypeParams = new HashSet<string>(targetGenericNames);
        foreach (var param in method.GenericParameters)
        {
            allowedTypeParams.Add(param.Name);
        }

        // Only emit method-level generics if there are non-collapsed ones
        if (methodGenericsToEmit.Count > 0)
        {
            sb.Append('<');
            var genericParams = new List<string>();
            foreach (var param in methodGenericsToEmit)
            {
                genericParams.Add(param.Name);
            }
            sb.Append(string.Join(", ", genericParams));
            sb.Append('>');
        }

        // Parameters
        sb.Append('(');
        var paramStrings = new List<string>();
        foreach (var param in instanceParams)
        {
            // Use TypeRefPrinter to print parameter types properly
            var paramType = TypeRefPrinter.Print(param.Type, resolver, ctx, allowedTypeParams);
            paramStrings.Add($"{param.Name}: {paramType}");
        }
        sb.Append(string.Join(", ", paramStrings));
        sb.Append(')');

        // Return type - use TypeRefPrinter
        var returnType = TypeRefPrinter.Print(method.ReturnType, resolver, ctx, allowedTypeParams);
        sb.Append($": {returnType}");

        sb.AppendLine(";");
    }

    /// <summary>
    /// Emit the ExtensionMethods&lt;TShape&gt; conditional type helper.
    /// This maps base types to their extension method buckets.
    /// </summary>
    private static void EmitExtensionMethodsHelper(StringBuilder sb, ExtensionMethodsPlan plan, SymbolGraph graph)
    {
        if (plan.Buckets.Length == 0)
        {
            return;
        }

        sb.AppendLine("// Generic helper type for mapping shapes to their extension methods");
        sb.AppendLine("// Usage: type Rich<T> = BaseType<T> & ExtensionMethods<BaseType<T>>");
        sb.AppendLine("export type ExtensionMethods<TShape> =");

        var isFirst = true;
        foreach (var bucket in plan.Buckets)
        {
            var targetType = bucket.TargetType;
            var namespaceAlias = targetType.Namespace.Replace('.', '_');

            var prefix = isFirst ? "  " : ": ";
            sb.Append(prefix);

            // Build the conditional: TShape extends Namespace.TypeName<...> ?
            sb.Append($"TShape extends {namespaceAlias}.{targetType.TsEmitName}");

            if (targetType.GenericParameters.Length > 0)
            {
                // Generic type: use infer to extract type arguments
                // If bucket has IEquatable constraint, propagate it to infer clause
                // Example: TShape extends System.Span_1<infer T extends IEquatable_1<T>> ? __Ext_Span_1<T>
                var inferParams = new List<string>();
                for (int i = 0; i < targetType.GenericParameters.Length; i++)
                {
                    var param = targetType.GenericParameters[i];
                    var needsIEquatable = BucketNeedsIEquatableConstraint(bucket, param.Name);

                    if (needsIEquatable)
                    {
                        inferParams.Add($"infer T{i} extends System.IEquatable_1<T{i}>");
                    }
                    else
                    {
                        inferParams.Add($"infer T{i}");
                    }
                }
                sb.Append($"<{string.Join(", ", inferParams)}> ? {bucket.BucketInterfaceName}<{string.Join(", ", Enumerable.Range(0, targetType.GenericParameters.Length).Select(i => $"T{i}"))}>");
            }
            else
            {
                // Non-generic type
                sb.Append($" ? {bucket.BucketInterfaceName}");
            }

            sb.AppendLine();
            isFirst = false;
        }

        // Default case: no extensions available
        sb.AppendLine("  : {};");
        sb.AppendLine();
    }
}

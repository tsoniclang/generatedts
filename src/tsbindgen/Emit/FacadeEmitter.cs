using System.IO;
using System.Linq;
using System.Text;
using tsbindgen.Model;
using tsbindgen.Plan;

namespace tsbindgen.Emit;

/// <summary>
/// Emits facade/index.d.ts files for each namespace.
/// Generates public-facing TypeScript declarations with proper imports and re-exports.
/// </summary>
public static class FacadeEmitter
{
    public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
    {
        ctx.Log("FacadeEmitter", "Generating facade index.d.ts files...");

        var emittedCount = 0;

        // Process each namespace in order
        foreach (var nsOrder in plan.EmissionOrder.Namespaces)
        {
            var ns = nsOrder.Namespace;
            ctx.Log("FacadeEmitter", $"  Emitting facade for: {ns.Name}");

            // Generate facade content
            var content = GenerateFacade(ctx, plan, ns);

            // Write to file: output/Namespace.Name/index.d.ts
            var namespacePath = Path.Combine(outputDirectory, ns.Name);
            Directory.CreateDirectory(namespacePath);

            var outputFile = Path.Combine(namespacePath, "index.d.ts");
            File.WriteAllText(outputFile, content);

            ctx.Log("FacadeEmitter", $"    â†’ {outputFile}");
            emittedCount++;
        }

        ctx.Log("FacadeEmitter", $"Generated {emittedCount} facade files");
    }

    private static string GenerateFacade(BuildContext ctx, EmissionPlan plan, Model.Symbols.NamespaceSymbol ns)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// Generated by tsbindgen - Architecture");
        sb.AppendLine($"// Namespace: {ns.Name}");
        sb.AppendLine($"// Facade - Public API Surface");
        sb.AppendLine();

        // Import from internal/index.d.ts (or _root/index.d.ts for empty namespace)
        sb.AppendLine("// Import internal declarations");
        var subdirName = ns.IsRoot ? "_root" : "internal";
        sb.AppendLine($"import * as Internal from './{subdirName}/index';");
        sb.AppendLine();

        // Convenience cross-namespace imports for common runtime types (Task/ValueTask)
        if (ns.Name == "System")
        {
            sb.AppendLine("// Convenience aliases from System.Threading.Tasks");
            sb.AppendLine("import type { Task as TaskNonGeneric, Task_1 as TaskGeneric, ValueTask as ValueTaskNonGeneric, ValueTask_1 as ValueTaskGeneric } from '../System.Threading.Tasks/internal/index';");
            sb.AppendLine();
        }

        if (plan.Imports.NamespaceExports.TryGetValue(ns.Name, out var exports) && exports.Count > 0)
        {
            // Precompute stem info
            var stemGroups = exports
                .GroupBy(e => GetStem(e.ExportName))
                .ToDictionary(g => g.Key, g => g.ToList());

            var nonGenericRenames = new Dictionary<string, string>(StringComparer.Ordinal); // original export name -> renamed alias
            var stemsWithGeneric = new HashSet<string>(StringComparer.Ordinal);
            var reservedStems = new HashSet<string>(StringComparer.Ordinal) { "Action", "Func" };
            var potentialFriendlyStems = new HashSet<string>(exports
                .Where(e => e.SourceType.GenericParameters.Length > 0)
                .Select(e => GetStem(e.ExportName)), StringComparer.Ordinal);

            foreach (var kvp in stemGroups)
            {
                var stem = kvp.Key;
                var group = kvp.Value;
                var hasNonGeneric = group.Any(e => e.Arity == 0);
                var hasGeneric = group.Any(e => e.Arity > 0);
                if (hasNonGeneric && hasGeneric)
                {
                    stemsWithGeneric.Add(stem);
                    if (!reservedStems.Contains(stem))
                    {
                        // Rename the non-generic export to <Stem>_0
                        var nonGenericExport = group.First(e => e.Arity == 0);
                        nonGenericRenames[nonGenericExport.ExportName] = stem + "_0";
                    }
                }
            }

            // Flat ESM: import cross-namespace types for constraints (type-only)
            var importedTypeNames = new HashSet<string>(StringComparer.Ordinal);

            if (plan.Imports.NamespaceImports.TryGetValue(ns.Name, out var imports) && imports.Count > 0)
            {
                sb.AppendLine("// Cross-namespace type imports for constraints");
                foreach (var import in imports.OrderBy(i => i.ImportPath))
                {
                    var typeImports = import.TypeImports;
                    if (typeImports.Count == 0)
                        continue;

                    var typeList = string.Join(", ", typeImports
                        .OrderBy(ti => ti.TypeName)
                        .Select(ti =>
                        {
                            var name = ti.TypeName;
                            var needsAlias = potentialFriendlyStems.Contains(GetStem(name)) && string.IsNullOrEmpty(ti.Alias);
                            var alias = needsAlias ? name + "_Imported" : ti.Alias;
                            var emit = alias != null ? $"{name} as {alias}" : name;
                            importedTypeNames.Add(alias ?? name);
                            return emit;
                        }));

                    var facadePath = import.ImportPath switch
                    {
                        // internal files are one level deeper than facades (../)
                        var p when p.StartsWith("../../") => "../" + p.Substring(6),
                        _ => import.ImportPath
                    };
                    sb.AppendLine($"import type {{ {typeList} }} from '{facadePath}';");
                }
                sb.AppendLine();
            }

            // Flattened ESM: re-export everything from internal
            sb.AppendLine($"export * from './{subdirName}/index';");
            sb.AppendLine();

            // Publish Task/ValueTask convenience aliases on System facade
            if (ns.Name == "System")
            {
                sb.AppendLine("// Friendly aliases for Task/ValueTask");
                sb.AppendLine("export type Task_0 = TaskNonGeneric;");
                sb.AppendLine("export type Task<T> = TaskGeneric<T>;");
                sb.AppendLine("export type ValueTask_0 = ValueTaskNonGeneric;");
                sb.AppendLine("export type ValueTask<T> = ValueTaskGeneric<T>;");
                sb.AppendLine();
            }

            sb.AppendLine("// Individual type exports for convenience");

            // TS2304 FIX: Create TypeNameResolver in facade mode to qualify cross-namespace types
            // This ensures constraints like "T extends IEquatable_1<T>" become "T extends System.IEquatable_1<T>"
            // Use ImportPlan so type-only imports can be referenced without qualification
            var resolver = new TypeNameResolver(ctx, plan.Graph, importPlan: plan.Imports, currentNamespace: ns.Name, facadeMode: false);

            // Track friendly aliases (arityless) to avoid duplicates
            var friendlyAliases = new HashSet<string>();
            var existingNames = new HashSet<string>(exports.Select(e => e.ExportName));
            var skipFriendlyNames = new HashSet<string>(importedTypeNames, StringComparer.Ordinal);
            foreach (var reserved in reservedStems)
            {
                skipFriendlyNames.Add(reserved);
            }

            foreach (var export in exports)
            {
                // Skip base Action to allow custom delegate alias below
                if (ns.Name == "System" && export.ExportName == "Action")
                {
                    continue;
                }

                var exportKind = export.ExportKind switch
                {
                    ExportKind.Class => "class",
                    ExportKind.Interface => "interface",
                    ExportKind.Enum => "enum",
                    ExportKind.Type => "type",
                    ExportKind.Const => "const",
                    _ => "type"
                };

                    // TS2315 FIX: Skip facade exports for types that lose their generics during emission
                    // Static classes with generic static members are emitted as non-generic classes
                    // (TypeScript doesn't support class-level generics for static-only classes)
                    if (export.SourceType.Kind == Model.Symbols.TypeKind.StaticNamespace &&
                        export.SourceType.GenericParameters.Length > 0)
                    {
                        ctx.Log("TS2315Fix", $"Skipping facade export for {export.ExportName} (static class with generics - emitted without generic parameters)");
                        continue;
                    }

                    // FACADE CONSTRAINTS: Use unified alias emitter with constraints
                    // STEP 1 RE-EXPORT FIX: Reference the top-level type aliases from internal/index.d.ts
                    // internal/index.d.ts exports: export type Console = Internal.Console$instance;
                    // So facade should use: Internal.Console (the top-level alias, not Internal.Internal.Console)
                    // This follows Option A from architect spec: facade points through top-level aliases
                    var rhsBase = $"Internal.{export.ExportName}";

                    // Apply rename for non-generic when sharing stem with generic
                    var aliasName = nonGenericRenames.TryGetValue(export.ExportName, out var renamed)
                        ? renamed
                        : export.ExportName;

                    AliasEmit.EmitGenericAlias(
                        sb,
                        aliasName: aliasName,
                        sourceType: export.SourceType,
                        rhsExpression: rhsBase,
                        resolver,
                        ctx,
                        withConstraints: true); // Facade preserves constraints

                    // FRIENDLY GENERIC ALIAS: Provide arity-less name (List instead of List_1)
                    if (export.SourceType.GenericParameters.Length > 0)
                    {
                        var suffix = $"_{export.SourceType.GenericParameters.Length}";
                        if (export.ExportName.EndsWith(suffix, StringComparison.Ordinal))
                        {
                            var friendlyName = export.ExportName.Substring(0, export.ExportName.Length - suffix.Length);
                            // Skip if we've already emitted or name collides with imports/reserved helpers
                            if (!string.IsNullOrWhiteSpace(friendlyName) &&
                                !skipFriendlyNames.Contains(friendlyName) &&
                                friendlyAliases.Add(friendlyName))
                            {
                                AliasEmit.EmitGenericAlias(
                                    sb,
                                    aliasName: friendlyName,
                                    sourceType: export.SourceType,
                                    rhsExpression: rhsBase,
                                    resolver,
                                    ctx,
                                    withConstraints: true);
                            }
                        }
                    }
                }

            }


        // Delegate convenience aliases (Action/Func) with callable compatibility
        // Only for System namespace which defines the standard delegates
        if (ns.Name == "System")
        {
            AppendDelegateAliases(sb, ctx, plan.Graph);
        }

        return sb.ToString();
    }

    /// <summary>
    /// Appends Action/Func helper aliases that route to the correct arity and accept TS lambdas.
    /// </summary>
    private static void AppendDelegateAliases(StringBuilder sb, BuildContext ctx, SymbolGraph graph)
    {
        var systemNamespace = graph.Namespaces.FirstOrDefault(n => n.Name == "System");
        if (systemNamespace == null)
            return;

        var actionTypes = systemNamespace.Types
            .Where(t => t.ClrFullName.StartsWith("System.Action"))
            .ToDictionary(t => t.GenericParameters.Length, t => t);

        var funcTypes = systemNamespace.Types
            .Where(t => t.ClrFullName.StartsWith("System.Func"))
            .ToDictionary(t => t.GenericParameters.Length, t => t);

        var maxActionArity = actionTypes.Keys.Any() ? actionTypes.Keys.Max() : -1;
        var maxFuncArity = funcTypes.Keys.Any() ? funcTypes.Keys.Max() : -1;

        if (maxActionArity < 0 && maxFuncArity < 0)
            return; // No delegates found

        sb.AppendLine();
        sb.AppendLine("// Delegate shortcut aliases (support TS lambdas)");
        sb.AppendLine("declare const __unspecified: unique symbol;");
        sb.AppendLine("export type __ = typeof __unspecified;");
        sb.AppendLine();

        if (maxActionArity == 0)
        {
            var action0 = actionTypes[0];
            var tsName = ctx.Renamer.GetFinalTypeName(action0);
            sb.AppendLine($"export type Action = ((() => void) | Internal.{tsName});");
            sb.AppendLine();
        }
        else if (maxActionArity > 0)
        {
            sb.AppendLine("export type Action<");
            for (int i = 1; i <= maxActionArity; i++)
            {
                sb.AppendLine($"  T{i} = __,");
            }
            sb.AppendLine("> =");

            for (int g = 0; g <= maxActionArity; g++)
            {
                if (!actionTypes.TryGetValue(g, out var actionType))
                    continue;

                var tsName = ctx.Renamer.GetFinalTypeName(actionType);
                var callSig = g == 0
                    ? "() => void"
                    : $"({string.Join(", ", Enumerable.Range(1, g).Select(n => $"arg{n}: T{n}"))}) => void";

                var typeArgs = g == 0 ? string.Empty : $"<{string.Join(", ", Enumerable.Range(1, g).Select(n => $"T{n}"))}>";
                var isLast = g == maxActionArity;
                var conditionIndex = g + 1;
                if (!isLast)
                {
                    sb.AppendLine($"  [T{conditionIndex}] extends [__] ? (({callSig}) | Internal.{tsName}{typeArgs}) :");
                }
                else
                {
                    sb.AppendLine($"  (({callSig}) | Internal.{tsName}{typeArgs});");
                }
            }

            sb.AppendLine();
        }

        if (maxFuncArity >= 1)
        {
            sb.AppendLine("export type Func<");
            for (int i = 1; i <= maxFuncArity; i++)
            {
                sb.AppendLine($"  T{i} = __,");
            }
            sb.AppendLine("> =");

            for (int g = 1; g <= maxFuncArity; g++)
            {
                if (!funcTypes.TryGetValue(g, out var funcType))
                    continue;

                var argCount = g - 1;
                var resultIndex = g;
                var tsName = ctx.Renamer.GetFinalTypeName(funcType);

                var callSig = argCount == 0
                    ? $"() => T{resultIndex}"
                    : $"({string.Join(", ", Enumerable.Range(1, argCount).Select(n => $"arg{n}: T{n}"))}) => T{resultIndex}";

                var typeArgs = string.Join(", ", Enumerable.Range(1, g).Select(n => $"T{n}"));
                var isLast = g == maxFuncArity;
                var conditionIndex = g + 1;
                if (!isLast)
                {
                    sb.AppendLine($"  [T{conditionIndex}] extends [__] ? (({callSig}) | Internal.{tsName}<{typeArgs}>) :");
                }
                else
                {
                    sb.AppendLine($"  (({callSig}) | Internal.{tsName}<{typeArgs}>);");
                }
            }
        }
    }

    /// <summary>
    /// FACADE CONSTRAINTS: Generates generic type parameters WITH constraints for facade type aliases.
    /// Mirrors source type's generic parameter constraints to maintain type safety across facade boundary.
    ///
    /// Examples:
    ///   No constraints: "<T>" or "<T1, T2>"
    ///   With constraints: "<T extends IEquatable_1<T>>"
    ///   Multiple constraints: "<T extends IComparable_1<T> & IEquatable_1<T>>"
    ///   Mixed: "<T, U extends IComparer_1<T>>"
    ///
    /// CLROf wrapping is automatically applied by TypeRefPrinter for primitive type arguments in constraints.
    /// </summary>
    private static string GenerateTypeParametersWithConstraints(
        Model.Symbols.TypeSymbol sourceType,
        TypeNameResolver resolver,
        BuildContext ctx)
    {
        var gps = sourceType.GenericParameters;
        if (gps.Length == 0)
            return string.Empty;

        var parts = new List<string>(gps.Length);

        foreach (var gp in gps)
        {
            // Collect type constraints (interfaces/classes)
            // Skip C# special constraints (struct, class, new()) as TypeScript can't express them
            var typeConstraints = gp.Constraints
                .Where(c => c is not null && !IsSpecialConstraint(c))
                .ToList();

            if (typeConstraints.Count == 0)
            {
                // No constraints: just the parameter name
                parts.Add(gp.Name);
            }
            else
            {
                // Print each constraint using TypeRefPrinter (handles CLROf, imports, etc.)
                var constraintStrings = typeConstraints
                    .Select(c => Printers.TypeRefPrinter.Print(c, resolver, ctx))
                    .ToArray();

                // Join multiple constraints with & (intersection type)
                var constraintList = string.Join(" & ", constraintStrings);
                parts.Add($"{gp.Name} extends {constraintList}");
            }
        }

        return $"<{string.Join(", ", parts)}>";
    }

    /// <summary>
    /// Check if a constraint is a C# special constraint (struct, class, new()).
    /// These don't translate to TypeScript and should be filtered out.
    ///
    /// In current model, special constraints are NOT represented as TypeReferences in Constraints array,
    /// so this is a defensive check that always returns false.
    /// </summary>
    private static bool IsSpecialConstraint(Model.Types.TypeReference constraint)
    {
        // Special constraints (struct, class, new()) are not in GenericParameter.Constraints
        // They're represented by separate flags in the model
        // This method is here for future-proofing in case the model changes
        return false;
    }

    /// <summary>
    /// Generates simple type argument list for RHS of facade alias (no constraints).
    /// Uses actual generic parameter names from source type for consistency.
    /// Examples: "<T>", "<TKey, TValue>", "<T1, T2, T3>"
    /// </summary>
    private static string GenerateTypeArguments(Model.Symbols.TypeSymbol sourceType)
    {
        var gps = sourceType.GenericParameters;
        if (gps.Length == 0)
            return string.Empty;

        var names = gps.Select(gp => gp.Name);
        return $"<{string.Join(", ", names)}>";
    }

    /// <summary>
    /// DEPRECATED: Old arity-based parameter generator.
    /// Use GenerateTypeParametersWithConstraints instead to preserve type safety.
    /// Kept for reference during migration.
    /// </summary>
    private static string GenerateTypeParameters(int arity)
    {
        if (arity == 0)
            return string.Empty;

        if (arity == 1)
            return "<T>";

        // For arity > 1, use T1, T2, T3, ...
        var typeParams = string.Join(", ", Enumerable.Range(1, arity).Select(i => $"T{i}"));
        return $"<{typeParams}>";
    }

    /// <summary>
    /// Get the stem name by stripping generic arity suffix (_1, _2, ...).
    /// </summary>
    private static string GetStem(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
            return name;

        var lastUnderscore = name.LastIndexOf('_');
        if (lastUnderscore >= 0 && lastUnderscore < name.Length - 1)
        {
            var suffix = name.Substring(lastUnderscore + 1);
            if (int.TryParse(suffix, out _))
            {
                return name.Substring(0, lastUnderscore);
            }
        }

        return name;
    }
}

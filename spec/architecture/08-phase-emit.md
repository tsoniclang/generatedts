# Phase 4: Emit - Output File Generation

## Overview

The **Emit Phase** is the fourth and final phase of the single-phase architecture. It takes the validated `EmissionPlan` (from the Plan phase) and generates all output files:

1. **TypeScript Declarations** - Public-facing `.d.ts` files with TypeScript type definitions
2. **Internal Declarations** - Internal implementation `.d.ts` files with actual type definitions
3. **Metadata Sidecars** - `metadata.json` files with CLR-specific information for Tsonic compiler
4. **Binding Metadata** - `bindings.json` files mapping TypeScript names to CLR names
5. **Module Stubs** - `index.js` stub files that throw at runtime (prevent execution)
6. **Support Types** - Centralized `_support/types.d.ts` with marker types for unsafe constructs

**Key Principles:**
- **Uses Renamer for all names** - Single source of truth for TypeScript identifiers
- **Respects EmitScope** - Only emits members with ClassSurface/StaticSurface/ViewOnly scopes
- **Type safety via TypeNameResolver** - Never uses CLR names directly
- **Deterministic output** - Uses EmitOrder from Plan phase for stable ordering

---

## File Organization

### Output Directory Structure

```
output/
  System/
    index.d.ts              # Public facade (re-exports from internal/)
    index.js                # Runtime stub (throws)
    bindings.json           # CLR name mappings
    internal/
      index.d.ts            # Actual type declarations
      metadata.json         # CLR-specific metadata
  System.Collections.Generic/
    index.d.ts
    index.js
    bindings.json
    internal/
      index.d.ts
      metadata.json
  _support/
    types.d.ts              # Shared marker types (TSUnsafePointer, TSByRef)
```

**Special Cases:**
- **Root namespace** (empty name): Uses `_root/` instead of `internal/` to avoid collision with "Internal" namespace
- **Dotted namespaces**: Cannot use `export import` syntax (TypeScript limitation)

---

## File: FacadeEmitter.cs

### Purpose
Generates public-facing `index.d.ts` files for each namespace. These are the entry points that users import from.

### Method: Emit()
```csharp
public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
```
**What it does:**
- Iterates through `plan.EmissionOrder.Namespaces` in deterministic order
- For each namespace, generates facade content via `GenerateFacade()`
- Writes to `output/{namespace}/index.d.ts`
- Logs each emitted file

**Output structure:**
- File header with generation info
- Import from `internal/index.d.ts` (or `_root/index.d.ts` for root namespace)
- Imports from dependencies (other namespaces)
- Re-export namespace (for non-dotted namespaces)
- Individual type exports for convenience

### Method: GenerateFacade()
```csharp
private static string GenerateFacade(BuildContext ctx, EmissionPlan plan, Model.Symbols.NamespaceSymbol ns)
```
**What it does:**
1. **File header** - Comments with namespace name and purpose
2. **Internal import** - `import * as Internal from './internal/index';`
3. **Dependency imports** - Cross-namespace references with aliases
4. **Namespace re-export** - `export import System = Internal.System;` (non-dotted only)
5. **Individual type exports** - `export type List_1 = Internal.System.Collections.Generic.List_1;`

**Algorithm:**
- Uses `plan.Imports.NamespaceImports` to get required imports
- Uses `plan.Imports.NamespaceExports` to get types to re-export
- Handles root namespace specially (no namespace wrapper, direct re-export)
- Skips dotted namespaces for `export import` (TypeScript doesn't support dots in identifiers)

### Method: GetImportAlias()
```csharp
private static string GetImportAlias(string namespaceName)
```
**What it does:**
- Converts dotted namespace to valid identifier: `"System.Collections.Generic"` → `"System_Collections_Generic"`

### Output Format Example

```typescript
// Generated by tsbindgen - Single-Phase Architecture
// Namespace: System.Collections.Generic
// Facade - Public API Surface

// Import internal declarations
import * as Internal from './internal/index';

// Import dependencies
import * as System from '../System/index';

// Re-export namespace
export import Generic = Internal.System.Collections.Generic;

// Individual type exports for convenience
export type List_1 = Internal.System.Collections.Generic.List_1;
export type Dictionary_2 = Internal.System.Collections.Generic.Dictionary_2;
```

---

## File: InternalIndexEmitter.cs

### Purpose
Generates `internal/index.d.ts` files with actual TypeScript declarations. These contain the real type definitions that the facade re-exports.

### Method: ShouldEmit()
```csharp
public static bool ShouldEmit(TypeSymbol type)
```
**What it does:**
- Returns `true` only for public types (`type.Accessibility == Accessibility.Public`)
- Internal types are never emitted to `.d.ts` files

### Method: Emit()
```csharp
public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
```
**What it does:**
- Iterates through `plan.EmissionOrder.Namespaces`
- For each namespace, generates declarations via `GenerateNamespaceDeclaration()`
- Writes to `output/{namespace}/internal/index.d.ts` (or `_root/index.d.ts` for root)
- Creates subdirectory if needed

### Method: GenerateNamespaceDeclaration()
```csharp
private static string GenerateNamespaceDeclaration(BuildContext ctx, SymbolGraph graph, ImportPlan importPlan, NamespaceEmitOrder nsOrder)
```
**What it does:**
1. **Creates TypeNameResolver** - Single source of truth for type names
2. **File header** - Comments with namespace and contributing assemblies
3. **Emits branded primitives** - All namespaces get `type int = number & { __brand: "int" };` etc.
4. **Conditional support types import** - If namespace uses pointers/byrefs, imports from `_support/types.d.ts`
5. **Cross-namespace imports** - Type imports from other namespaces with aliases if needed
6. **Namespace wrapper** - `export namespace Foo {` (skipped for root namespace)
7. **Type declarations** - Iterates through `nsOrder.OrderedTypes` and emits each

**Algorithm:**
- Calls `NamespaceUsesSupportTypes()` to check if `TSUnsafePointer`/`TSByRef` needed
- Uses `importPlan.GetImportsFor()` to get cross-namespace imports
- For root namespace, emits types at module level (no namespace wrapper)
- For each type, checks if it has explicit views (companion views pattern):
  - **With views**: Emits `TypeName$instance` class + `__TypeName$views` interface + intersection type alias
  - **Without views**: Emits normal class/interface/enum/delegate

### Method: EmitBrandedPrimitives()
```csharp
private static void EmitBrandedPrimitives(StringBuilder sb)
```
**What it does:**
- Emits branded primitive type aliases for all CLR numeric types:
  - `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`
  - `float`, `double`, `decimal`, `nint`, `nuint`

### Method: EmitCompanionViewsInterface()
```csharp
private static string EmitCompanionViewsInterface(TypeSymbol type, ImmutableArray<Shape.ViewPlanner.ExplicitView> views, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Generates companion interface with view properties: `interface __List_1$views<T> { ... }`
- Each view becomes a readonly property: `readonly IEnumerable_1$view: IEnumerable_1<T>;`

### Method: EmitIntersectionTypeAlias()
```csharp
private static string EmitIntersectionTypeAlias(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Creates type alias that intersects instance and views:
  - `export type List_1<T> = List_1$instance<T> & __List_1$views<T>;`

### Method: FindMatchingInterface() - FIX D
```csharp
private static TypeReference? FindMatchingInterface(TypeSymbol type, TypeReference viewInterfaceRef)
```
**Lines:** 283-300

**Purpose:** Find the matching interface in `type.Interfaces` that corresponds to the view's interface reference, with correct type arguments substituted.

**Problem it solves:**
```csharp
// ViewPlanner creates ExplicitView with interface reference like:
view.InterfaceReference = IEnumerable<T>  // Generic parameter T (open generic)

// But class implements the interface with concrete type:
class List<T> : IEnumerable<T> { }
type.Interfaces = [ IEnumerable<T> ]  // Actual type argument matches class's T

// WITHOUT FIX D:
interface __List_1$views<T> {
  readonly IEnumerable_1$view: IEnumerable_1<T>;  // Correct by luck
}

// But for classes with different type parameters:
class Dictionary<TKey, TValue> : IEnumerable<KeyValuePair<TKey, TValue>> { }
view.InterfaceReference = IEnumerable<T>  // Wrong! Should be KeyValuePair<TKey, TValue>

// WITH FIX D:
interface __Dictionary_2$views<TKey, TValue> {
  readonly IEnumerable_1$view: IEnumerable_1<KeyValuePair<TKey, TValue>>;  // Correct!
}
```

**Algorithm:**
1. **Get view interface base name:**
   - Call `GetInterfaceBaseName(viewInterfaceRef)` to extract interface name
   - Example: `IEnumerable\`1` (without type arguments)

2. **Search type's implemented interfaces:**
   - For each `implementedInterface` in `type.Interfaces`:
     - Get base name: `GetInterfaceBaseName(implementedInterface)`
     - If base names match: return `implementedInterface`

3. **Return:**
   - Matched interface (with correct type arguments), or `null` if not found

**Why needed:** ViewPlanner stores interface references with generic parameters from the interface's perspective, but when emitting companion views, we need the type arguments from the implementing class's perspective.

**Example:**
```csharp
// Input:
type = Dictionary<TKey, TValue> (implements IEnumerable<KeyValuePair<TKey, TValue>>)
viewInterfaceRef = IEnumerable<T> (from ViewPlanner, generic param)

// Processing:
viewBaseName = "IEnumerable`1"
type.Interfaces[0] = IEnumerable<KeyValuePair<TKey, TValue>>
implBaseName = "IEnumerable`1"
Match! Return IEnumerable<KeyValuePair<TKey, TValue>>

// Used in EmitCompanionViewsInterface():
var matchedInterface = FindMatchingInterface(type, view.InterfaceReference);
// Result: IEnumerable<KeyValuePair<TKey, TValue>> (not IEnumerable<T>)
```

**Called by:** `EmitCompanionViewsInterface()` at line 267 for each view property

**Impact:** Prevents generic parameter leaks in companion views. Without this, view properties would use orphaned generic parameters instead of the class's actual type arguments.

### Method: GetInterfaceBaseName() - FIX D Helper
```csharp
private static string GetInterfaceBaseName(TypeReference typeRef)
```
**Lines:** 306-314

**Purpose:** Extract the base name (without type arguments) from an interface reference for matching purposes.

**Examples:**
```csharp
NamedTypeReference("IEnumerator`1", [T])           → "IEnumerator`1"
NamedTypeReference("IEnumerable`1", [string])      → "IEnumerable`1"
NestedTypeReference("Outer`1+Inner")               → "Inner"
```

**Algorithm:**
- `NamedTypeReference named` → `named.Name` (just the name with arity marker)
- `NestedTypeReference nested` → `nested.NestedName`
- Other types → `typeRef.ToString()` or empty string

**Why needed:** Interface matching must ignore type arguments and compare only the base generic definition. `IEnumerable<T>` and `IEnumerable<string>` both have base name `IEnumerable\`1`.

**Used by:** `FindMatchingInterface()` to compare interface names

**Note:** Returns name WITH backtick arity (e.g., `IEnumerable\`1`), not without (e.g., `IEnumerable`). This is critical for distinguishing generic arities.

### Method: NamespaceUsesSupportTypes()
```csharp
private static bool NamespaceUsesSupportTypes(NamespaceSymbol ns)
```
**What it does:**
- Scans all public types and their ClassSurface/StaticSurface members
- Checks if any use `PointerTypeReference` or `ByRefTypeReference`
- Returns `true` if support types import needed

### Method: ContainsUnsafeType()
```csharp
private static bool ContainsUnsafeType(Model.Types.TypeReference typeRef)
```
**What it does:**
- Recursively checks type reference for pointers/byrefs
- Handles arrays (checks element type), named types (checks type arguments), nested types

### Output Format Example

```typescript
// Generated by tsbindgen - Single-Phase Architecture
// Namespace: System.Collections.Generic
// Assembly: System.Private.CoreLib

// Branded primitive types for CLR numeric types
export type sbyte = number & { __brand: "sbyte" };
export type byte = number & { __brand: "byte" };
export type int = number & { __brand: "int" };
// ... all primitives ...

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../_support/types";

// Import types from other namespaces
import type { Object, ValueType } from "../System/internal/index";

export namespace System.Collections.Generic {
    // With companion views:
    export class List_1$instance<T> {
        constructor(capacity: int);
        readonly Count: int;
        Add(item: T): void;
    }

    export interface __List_1$views<T> {
        readonly IEnumerable_1$view: IEnumerable_1<T>;
    }

    export type List_1<T> = List_1$instance<T> & __List_1$views<T>;

    // Without views:
    export interface IEnumerable_1<T> {
        GetEnumerator(): IEnumerator_1<T>;
    }
}
```

---

## File: MetadataEmitter.cs

### Purpose
Generates `metadata.json` files with CLR-specific information that TypeScript can't represent. Used by Tsonic compiler for correct C# code generation.

### Record: NamespaceMetadata
```csharp
public sealed record NamespaceMetadata
{
    public required string Namespace { get; init; }
    public required List<string> ContributingAssemblies { get; init; }
    public required List<TypeMetadata> Types { get; init; }
}
```

### Record: TypeMetadata
```csharp
public sealed record TypeMetadata
{
    public required string ClrName { get; init; }           // "System.Collections.Generic.List`1"
    public required string TsEmitName { get; init; }        // "List_1"
    public required string Kind { get; init; }              // "Class"
    public required string Accessibility { get; init; }      // "Public"
    public required bool IsAbstract { get; init; }
    public required bool IsSealed { get; init; }
    public required bool IsStatic { get; init; }
    public required int Arity { get; init; }
    public required List<MethodMetadata> Methods { get; init; }
    public required List<PropertyMetadata> Properties { get; init; }
    public required List<FieldMetadata> Fields { get; init; }
    public required List<EventMetadata> Events { get; init; }
    public required List<ConstructorMetadata> Constructors { get; init; }
}
```

### Record: MethodMetadata
```csharp
public sealed record MethodMetadata
{
    public required string ClrName { get; init; }                  // "Add"
    public required string TsEmitName { get; init; }               // "Add" or "IEnumerable_1$view$Add"
    public required string NormalizedSignature { get; init; }       // For universal matching
    public required string Provenance { get; init; }               // "Direct", "Inherited", "ExplicitImpl"
    public required string EmitScope { get; init; }                // "ClassSurface", "ViewOnly"
    public required bool IsStatic { get; init; }
    public required bool IsAbstract { get; init; }
    public required bool IsVirtual { get; init; }
    public required bool IsOverride { get; init; }
    public required bool IsSealed { get; init; }
    public required int Arity { get; init; }
    public required int ParameterCount { get; init; }
    public string? SourceInterface { get; init; }                  // For ViewOnly members
}
```

### Record: PropertyMetadata
```csharp
public sealed record PropertyMetadata
{
    public required string ClrName { get; init; }
    public required string TsEmitName { get; init; }
    public required string NormalizedSignature { get; init; }
    public required string Provenance { get; init; }
    public required string EmitScope { get; init; }
    public required bool IsStatic { get; init; }
    public required bool IsAbstract { get; init; }
    public required bool IsVirtual { get; init; }
    public required bool IsOverride { get; init; }
    public required bool IsIndexer { get; init; }
    public required bool HasGetter { get; init; }
    public required bool HasSetter { get; init; }
    public string? SourceInterface { get; init; }
}
```

### Record: FieldMetadata
```csharp
public sealed record FieldMetadata
{
    public required string ClrName { get; init; }
    public required string TsEmitName { get; init; }
    public required string NormalizedSignature { get; init; }
    public required bool IsStatic { get; init; }
    public required bool IsReadOnly { get; init; }
    public required bool IsLiteral { get; init; }              // const field
}
```

### Record: EventMetadata
```csharp
public sealed record EventMetadata
{
    public required string ClrName { get; init; }
    public required string TsEmitName { get; init; }
    public required string NormalizedSignature { get; init; }
    public required bool IsStatic { get; init; }
}
```

### Record: ConstructorMetadata
```csharp
public sealed record ConstructorMetadata
{
    public required string NormalizedSignature { get; init; }
    public required bool IsStatic { get; init; }
    public required int ParameterCount { get; init; }
}
```

### Method: Emit()
```csharp
public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
```
**What it does:**
- Iterates through `plan.EmissionOrder.Namespaces`
- For each namespace, generates metadata via `GenerateMetadata()`
- Writes to `output/{namespace}/internal/metadata.json`
- Uses indented JSON format with null value omission

### Method: GenerateMetadata()
```csharp
private static NamespaceMetadata GenerateMetadata(BuildContext ctx, NamespaceEmitOrder nsOrder)
```
**What it does:**
- Creates `NamespaceMetadata` with namespace name and contributing assemblies
- For each type in `nsOrder.OrderedTypes`, calls `GenerateTypeMetadata()`

### Method: GenerateTypeMetadata()
```csharp
private static TypeMetadata GenerateTypeMetadata(TypeSymbol type, BuildContext ctx)
```
**What it does:**
- Gets final TypeScript name from `ctx.Renamer.GetFinalTypeName(type)`
- Creates `TypeMetadata` with all type information
- Generates metadata for all member kinds (methods, properties, fields, events, constructors)

### Method: GenerateMethodMetadata()
```csharp
private static MethodMetadata GenerateMethodMetadata(MethodSymbol method, TypeSymbol declaringType, BuildContext ctx)
```
**What it does:**
- Uses **view scope** for ViewOnly members (via `ScopeFactory.ViewSurface()`)
- Uses **class scope** for ClassSurface members (via `ScopeFactory.ClassSurface()`)
- Gets final TS name from `ctx.Renamer.GetFinalMemberName()`
- Generates normalized signature via `SignatureNormalization.NormalizeMethod()`

**Key Decision:**
- ViewOnly members get view-scoped names: `"IEnumerable_1$view$GetEnumerator"`
- ClassSurface members get class-scoped names: `"GetEnumerator"`

### Output Format Example

```json
{
  "Namespace": "System.Collections.Generic",
  "ContributingAssemblies": [
    "System.Private.CoreLib"
  ],
  "Types": [
    {
      "ClrName": "System.Collections.Generic.List`1",
      "TsEmitName": "List_1",
      "Kind": "Class",
      "Accessibility": "Public",
      "IsAbstract": false,
      "IsSealed": false,
      "IsStatic": false,
      "Arity": 1,
      "Methods": [
        {
          "ClrName": "Add",
          "TsEmitName": "Add",
          "NormalizedSignature": "Add(T):System.Void",
          "Provenance": "Direct",
          "EmitScope": "ClassSurface",
          "IsStatic": false,
          "IsAbstract": false,
          "IsVirtual": false,
          "IsOverride": false,
          "IsSealed": false,
          "Arity": 0,
          "ParameterCount": 1
        },
        {
          "ClrName": "GetEnumerator",
          "TsEmitName": "IEnumerable_1$view$GetEnumerator",
          "NormalizedSignature": "GetEnumerator():System.Collections.Generic.IEnumerator`1<T>",
          "Provenance": "ExplicitImpl",
          "EmitScope": "ViewOnly",
          "IsStatic": false,
          "IsAbstract": false,
          "IsVirtual": false,
          "IsOverride": false,
          "IsSealed": false,
          "Arity": 0,
          "ParameterCount": 0,
          "SourceInterface": "System.Collections.Generic.IEnumerable`1"
        }
      ],
      "Properties": [],
      "Fields": [],
      "Events": [],
      "Constructors": [
        {
          "NormalizedSignature": ".ctor(System.Int32):System.Void",
          "IsStatic": false,
          "ParameterCount": 1
        }
      ]
    }
  ]
}
```

---

## File: BindingEmitter.cs

### Purpose
Generates `bindings.json` files with CLR-to-TypeScript name mappings. Used by runtime for binding and Tsonic compiler for code generation.

### Record: NamespaceBindings
```csharp
public sealed record NamespaceBindings
{
    public required string Namespace { get; init; }
    public required List<TypeBinding> Types { get; init; }
}
```

### Record: TypeBinding
```csharp
public sealed record TypeBinding
{
    public required string ClrName { get; init; }           // "System.Collections.Generic.List`1"
    public required string TsEmitName { get; init; }        // "List_1"
    public required string AssemblyName { get; init; }      // "System.Private.CoreLib"
    public required int MetadataToken { get; init; }        // 0 for types
    public required List<MethodBinding> Methods { get; init; }
    public required List<PropertyBinding> Properties { get; init; }
    public required List<FieldBinding> Fields { get; init; }
    public required List<EventBinding> Events { get; init; }
    public required List<ConstructorBinding> Constructors { get; init; }
}
```

### Record: MethodBinding
```csharp
public sealed record MethodBinding
{
    public required string ClrName { get; init; }
    public required string TsEmitName { get; init; }
    public required int MetadataToken { get; init; }
    public required string CanonicalSignature { get; init; }    // From StableId
    public required string NormalizedSignature { get; init; }   // Universal format
    public required string EmitScope { get; init; }
    public required int Arity { get; init; }
    public required int ParameterCount { get; init; }
}
```

### Record: PropertyBinding
```csharp
public sealed record PropertyBinding
{
    public required string ClrName { get; init; }
    public required string TsEmitName { get; init; }
    public required int MetadataToken { get; init; }
    public required string CanonicalSignature { get; init; }
    public required string NormalizedSignature { get; init; }
    public required string EmitScope { get; init; }
    public required bool IsIndexer { get; init; }
    public required bool HasGetter { get; init; }
    public required bool HasSetter { get; init; }
}
```

### Record: FieldBinding
```csharp
public sealed record FieldBinding
{
    public required string ClrName { get; init; }
    public required string TsEmitName { get; init; }
    public required int MetadataToken { get; init; }
    public required string NormalizedSignature { get; init; }
    public required bool IsStatic { get; init; }
    public required bool IsReadOnly { get; init; }
}
```

### Record: EventBinding
```csharp
public sealed record EventBinding
{
    public required string ClrName { get; init; }
    public required string TsEmitName { get; init; }
    public required int MetadataToken { get; init; }
    public required string NormalizedSignature { get; init; }
    public required bool IsStatic { get; init; }
}
```

### Record: ConstructorBinding
```csharp
public sealed record ConstructorBinding
{
    public required int MetadataToken { get; init; }
    public required string CanonicalSignature { get; init; }
    public required string NormalizedSignature { get; init; }
    public required bool IsStatic { get; init; }
    public required int ParameterCount { get; init; }
}
```

### Method: Emit()
```csharp
public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
```
**What it does:**
- Iterates through `plan.EmissionOrder.Namespaces`
- For each namespace, generates bindings via `GenerateBindings()`
- Writes to `output/{namespace}/bindings.json`

### Method: GenerateBindings()
```csharp
private static NamespaceBindings GenerateBindings(BuildContext ctx, NamespaceEmitOrder nsOrder)
```
**What it does:**
- Creates `NamespaceBindings` with namespace name
- For each type in `nsOrder.OrderedTypes`, calls `GenerateTypeBinding()`

### Method: GenerateTypeBinding()
```csharp
private static TypeBinding GenerateTypeBinding(TypeSymbol type, BuildContext ctx)
```
**What it does:**
- Gets final TypeScript name from `ctx.Renamer.GetFinalTypeName(type)`
- Includes **ALL members** (ClassSurface, StaticSurface, AND ViewOnly)
- ViewOnly members get view-scoped names (e.g., `"IEnumerable_1$view$GetEnumerator"`)

**Key Decision:**
- Bindings include ViewOnly members (unlike declarations which only emit to views)
- This allows runtime to bind to explicit interface implementations

### Output Format Example

```json
{
  "Namespace": "System.Collections.Generic",
  "Types": [
    {
      "ClrName": "System.Collections.Generic.List`1",
      "TsEmitName": "List_1",
      "AssemblyName": "System.Private.CoreLib",
      "MetadataToken": 0,
      "Methods": [
        {
          "ClrName": "Add",
          "TsEmitName": "Add",
          "MetadataToken": 100663359,
          "CanonicalSignature": "Add(!0):System.Void",
          "NormalizedSignature": "Add(T):System.Void",
          "EmitScope": "ClassSurface",
          "Arity": 0,
          "ParameterCount": 1
        },
        {
          "ClrName": "GetEnumerator",
          "TsEmitName": "IEnumerable_1$view$GetEnumerator",
          "MetadataToken": 100663360,
          "CanonicalSignature": "GetEnumerator():System.Collections.Generic.IEnumerator`1<!0>",
          "NormalizedSignature": "GetEnumerator():System.Collections.Generic.IEnumerator`1<T>",
          "EmitScope": "ViewOnly",
          "Arity": 0,
          "ParameterCount": 0
        }
      ],
      "Properties": [],
      "Fields": [],
      "Events": [],
      "Constructors": []
    }
  ]
}
```

---

## File: ModuleStubEmitter.cs

### Purpose
Generates `index.js` stub files that throw at runtime. Prevents accidental execution while allowing TypeScript type checking.

### Method: Emit()
```csharp
public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
```
**What it does:**
- Iterates through `plan.EmissionOrder.Namespaces`
- For each namespace, generates stub via `GenerateStub()`
- Writes to `output/{namespace}/index.js`

### Method: GenerateStub()
```csharp
private static string GenerateStub(string namespaceName)
```
**What it does:**
- Creates JavaScript file with `throw new Error(...)` statement
- Error message explains this is type-only module requiring .NET runtime

### Output Format Example

```javascript
// Generated by tsbindgen - Single-Phase Architecture
// Namespace: System.Collections.Generic
// Module Stub - Do Not Execute

throw new Error(
  'Cannot import CLR namespace System.Collections.Generic in JavaScript runtime. ' +
  'This module provides TypeScript type definitions only. ' +
  'Actual implementation requires .NET runtime via Tsonic compiler.'
);
```

---

## File: SupportTypesEmitter.cs

### Purpose
Generates centralized `_support/types.d.ts` with marker types for unsafe CLR constructs. Emitted once for entire generation, not per-namespace.

### Method: Emit()
```csharp
public static void Emit(BuildContext ctx, string outputDirectory)
```
**What it does:**
- Creates `_support/` directory
- Generates content via `GenerateSupportTypes()`
- Writes to `output/_support/types.d.ts`

### Method: GenerateSupportTypes()
```csharp
private static string GenerateSupportTypes()
```
**What it does:**
- Emits `TSUnsafePointer<T>` type for pointer types (void*, int*, T*)
- Emits `TSByRef<T>` type for ref/out/in parameters

**Key Design:**
- `TSUnsafePointer<T>` erases to `unknown` for type safety (forces explicit handling)
- `TSByRef<T>` provides structural access via `.value` property
- Both use unique symbols for branding (maintains identity for auditing)

### Output Format Example

```typescript
// Generated by tsbindgen - Single-Phase Architecture
// Support Types Module
//
// These are opaque placeholders for CLR constructs that have no TS equivalent.
// They intentionally erase to `unknown` to keep the API sound.

/**
 * Marker type for C# pointer types (void*, int*, T*, etc.).
 * Erases to `unknown` for type safety - forces explicit handling.
 * The generic parameter preserves information about the pointed-to type.
 * Branded with unique symbol to maintain identity for auditing.
 */
export type TSUnsafePointer<T> = unknown & { readonly __tsbindgenPtr?: unique symbol };

/**
 * Marker type for C# ref/out/in parameters.
 * Provides structural access via `.value` to match C# semantics.
 * Branded with unique symbol to maintain identity for auditing.
 * Example: `method(arg: TSByRef<int>)` → caller uses `arg.value`
 */
export type TSByRef<T> = { value: T } & { readonly __tsbindgenByRef?: unique symbol };
```

---

## File: TypeMap.cs

### Purpose
Maps CLR built-in types to TypeScript types. Short-circuits graph lookups for primitives and special types. **CRITICAL:** Must be checked BEFORE TypeIndex lookup to avoid PG_LOAD_001 false positives.

### Method: TryMapBuiltin()
```csharp
public static bool TryMapBuiltin(string fullName, out string tsType)
```
**What it does:**
- Returns `true` if `fullName` is a known built-in type
- Sets `tsType` to the corresponding TypeScript type
- Returns `false` for non-built-in types

**Mappings:**

| CLR Type | TypeScript Type | Notes |
|----------|-----------------|-------|
| `System.Void` | `void` | |
| `System.Boolean` | `boolean` | |
| `System.String` | `string` | |
| `System.Object` | `any` | Maximum compatibility |
| `System.Char` | `string` | TS has no char type |
| `System.SByte` | `sbyte` | Branded type |
| `System.Byte` | `byte` | Branded type |
| `System.Int16` | `short` | Branded type |
| `System.UInt16` | `ushort` | Branded type |
| `System.Int32` | `int` | Branded type |
| `System.UInt32` | `uint` | Branded type |
| `System.Int64` | `long` | Branded type |
| `System.UInt64` | `ulong` | Branded type |
| `System.IntPtr` | `nint` | Branded type |
| `System.UIntPtr` | `nuint` | Branded type |
| `System.Single` | `float` | Branded type |
| `System.Double` | `double` | Branded type |
| `System.Decimal` | `decimal` | Branded type |
| `System.Array` | `any[]` | Base array type |
| `System.ValueType` | `any` | Base value type |
| `System.Enum` | `number` | Base enum type |
| `System.Delegate` | `Function` | |
| `System.MulticastDelegate` | `Function` | |

### Method: IsUnsupportedSpecialForm()
```csharp
public static bool IsUnsupportedSpecialForm(string fullName, bool isPointer, bool isByRef, bool isFunctionPointer)
```
**What it does:**
- Returns `true` if type is pointer, byref, or function pointer
- These require special handling or substitution

### Method: MapUnsupportedSpecialForm()
```csharp
public static string MapUnsupportedSpecialForm(string fullName, bool isPointer, bool isByRef, bool isFunctionPointer, bool allowUnsafeMaps)
```
**What it does:**
- If `allowUnsafeMaps` is `false`, throws exception
- If `allowUnsafeMaps` is `true`, returns `"any"`

### Method: IsBrandedPrimitive()
```csharp
public static bool IsBrandedPrimitive(string fullName)
```
**What it does:**
- Returns `true` for numeric types that should use branded syntax
- These are emitted as type aliases in file preamble

---

## File: TypeNameResolver.cs

### Purpose
Single source of truth for resolving TypeScript identifiers from TypeReferences. Uses the Renamer to ensure imports and declarations use identical names.

### Constructor
```csharp
public TypeNameResolver(BuildContext ctx, SymbolGraph graph)
```
**What it does:**
- Stores `BuildContext` (for Renamer access)
- Stores `SymbolGraph` (for TypeIndex lookups)

### Method: For(TypeSymbol)
```csharp
public string For(Model.Symbols.TypeSymbol type)
```
**What it does:**
- Returns final TypeScript identifier for a `TypeSymbol`
- Directly queries `ctx.Renamer.GetFinalTypeName(type)`

### Method: ResolveTypeName(NamedTypeReference)
```csharp
public string ResolveTypeName(NamedTypeReference named)
```
**What it does:**
- Wrapper for `For(NamedTypeReference)` to provide consistent API

### Method: For(NamedTypeReference)
```csharp
public string For(NamedTypeReference named)
```
**What it does:**
1. **Try TypeMap FIRST** - Short-circuit built-in types before graph lookup (prevents PG_LOAD_001)
2. **Look up TypeSymbol in graph** - Uses StableId (`{AssemblyName}:{FullName}`)
3. **If not in graph** - Type is external (from another assembly), sanitize CLR name
4. **Get final TypeScript name from Renamer** - Single source of truth

**Algorithm:**
```csharp
// 1. Try TypeMap (built-ins like System.Int32 → int)
if (TypeMap.TryMapBuiltin(named.FullName, out var builtinType))
    return builtinType;

// 2. Look up in graph
var stableId = $"{named.AssemblyName}:{named.FullName}";
if (!_graph.TypeIndex.TryGetValue(stableId, out var typeSymbol))
{
    // External type - sanitize CLR name
    return SanitizeClrName(simpleName);
}

// 3. Get final name from Renamer
return _ctx.Renamer.GetFinalTypeName(typeSymbol);
```

### Method: SanitizeClrName()
```csharp
private static string SanitizeClrName(string clrName)
```
**What it does:**
- Replaces generic arity backtick: `List`1` → `List_1`
- Replaces nested type separator: `Foo+Bar` → `Foo_Bar`
- Removes invalid TypeScript identifier characters

### Method: TryMapPrimitive()
```csharp
public static string? TryMapPrimitive(string clrFullName)
```
**What it does:**
- Static helper that calls `TypeMap.TryMapBuiltin()`
- Returns `null` if not a primitive

### Method: IsPrimitive()
```csharp
public static bool IsPrimitive(string clrFullName)
```
**What it does:**
- Returns `true` if type is a primitive that doesn't need imports

---

## File: Printers/ClassPrinter.cs

### Purpose
Prints TypeScript class declarations from TypeSymbol. Handles classes, structs, static classes, enums, delegates, and interfaces.

### Method: Print()
```csharp
public static string Print(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- **GUARD:** Never prints non-public types (logs rejection if attempted)
- Dispatches to specialized printer based on `type.Kind`:
  - `TypeKind.Class` → `PrintClass()`
  - `TypeKind.Struct` → `PrintStruct()`
  - `TypeKind.StaticNamespace` → `PrintStaticClass()`
  - `TypeKind.Enum` → `PrintEnum()`
  - `TypeKind.Delegate` → `PrintDelegate()`
  - `TypeKind.Interface` → `PrintInterface()`

### Method: PrintInstance()
```csharp
public static string PrintInstance(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints class/struct with `$instance` suffix (for companion views pattern)
- Used when type has explicit interface views
- Only classes and structs support this (other types fallback to normal Print)

### Method: PrintClass()
```csharp
private static string PrintClass(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx, bool instanceSuffix = false)
```
**What it does:**
1. Gets final TypeScript name from Renamer
2. Adds `$instance` suffix if requested
3. Emits class modifiers (`abstract` if abstract)
4. Emits generic parameters with constraints
5. Emits base class (`extends BaseClass`, skips Object/ValueType)
6. Emits interfaces (`implements IFoo, IBar`)
7. Calls `EmitMembers()` to emit body

### Method: PrintStruct()
```csharp
private static string PrintStruct(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx, bool instanceSuffix = false)
```
**What it does:**
- Structs emit as classes (metadata notes value semantics)
- Same as `PrintClass()` but no `abstract` modifier, no base class

### Method: PrintStaticClass()
```csharp
private static string PrintStaticClass(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Emits as `abstract class TypeName { ... }`
- Calls `EmitStaticMembers()` to emit static-only members

### Method: PrintEnum()
```csharp
private static string PrintEnum(TypeSymbol type, BuildContext ctx)
```
**What it does:**
1. Gets final TypeScript name from Renamer
2. Emits `enum TypeName { ... }`
3. Iterates through const fields (enum members)
4. Gets final member name from Renamer (using `ClassStatic` scope)
5. Emits `Name = Value,` for each member

### Method: PrintDelegate()
```csharp
private static string PrintDelegate(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
1. Gets final TypeScript name from Renamer
2. Emits `type TypeName<...> = ...`
3. Finds `Invoke` method
4. Emits function signature: `(a: int, b: string) => void`

### Method: PrintInterface()
```csharp
private static string PrintInterface(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
1. Gets final TypeScript name from Renamer
2. Emits `interface TypeName<...> extends ... { ... }`
3. Calls `EmitInterfaceMembers()` to emit body

### Method: EmitMembers()
```csharp
private static void EmitMembers(StringBuilder sb, TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Emits instance members:
  - Constructors (non-static)
  - Fields (non-static, ClassSurface only)
  - Properties (non-static, ClassSurface only)
  - Methods (non-static, ClassSurface only)
- Calls `EmitStaticMembers()` for static members
- Uses `ScopeFactory.ClassInstance(type)` for member name resolution

### Method: EmitStaticMembers() (**Updated in jumanji7**)
```csharp
private static void EmitStaticMembers(StringBuilder sb, TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Emits static members with special handling for generic classes:
  - **Fields** (static, non-const, ClassSurface or StaticSurface):
    - **NEW**: Calls `SubstituteClassGenericsInTypeRef()` to widen types referencing class generics to `unknown`
    - Prevents TS2302 error (static members cannot reference class type parameters)
  - **Const fields** (as `static readonly`, ClassSurface or StaticSurface):
    - **NEW**: Also substitutes class generics with `unknown`
  - **Properties** (static, ClassSurface or StaticSurface):
    - **NEW**: Substitutes class generics with `unknown`
  - **Methods** (static, ClassSurface or StaticSurface):
    - **NEW**: Calls `LiftClassGenericsToMethod()` to move class generic parameters to method level
    - Prevents TS2302 error (TypeScript doesn't support static methods using class type parameters)
- Uses `ScopeFactory.ClassStatic(type)` for member name resolution

**Why generic handling is needed:**

TypeScript does NOT allow static members to reference class-level type parameters:

```typescript
// ❌ INVALID TypeScript (TS2302 error)
class List<T> {
    static defaultValue: T;           // ERROR: Static member cannot reference class type parameter
    static createDefault(): T { ... } // ERROR: Static member cannot reference class type parameter
}
```

**jumanji7 solution:**
- **Static fields/properties**: Widen type to `unknown` (TypeScript limitation - cannot be made generic)
- **Static methods**: Lift class generics to method generics (makes method generic instead)

### Method: EmitInterfaceMembers()
```csharp
private static void EmitInterfaceMembers(StringBuilder sb, TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Emits interface members:
  - Properties (non-static, ClassSurface only) - static not supported in TS interfaces
  - Methods (non-static, ClassSurface only) - static not supported in TS interfaces
- Uses `ScopeFactory.ClassSurface()` for member name resolution

### Method: PrintGenericParameter()
```csharp
private static string PrintGenericParameter(GenericParameterSymbol gp, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Emits generic parameter with constraints
- Single constraint: `T extends IFoo`
- Multiple constraints: `T extends IFoo & IBar` (intersection)

### Method: LiftClassGenericsToMethod() (**NEW in jumanji7**)

```csharp
private static MethodSymbol LiftClassGenericsToMethod(MethodSymbol method, TypeSymbol declaringType, BuildContext ctx)
```

**Purpose:** Lifts class-level generic parameters to method-level for static methods. Solves TS2302 error (static members cannot reference class type parameters).

**Problem it solves:**

```csharp
// C# code (valid):
class Array<T> {
    public static void Sort<TKey>(T[] keys, TKey[] items) { ... }
}

// TypeScript (INVALID - TS2302):
class Array_1<T> {
    static sort<TKey>(keys: T[], items: TKey[]): void;  // ❌ ERROR: Cannot reference 'T' in static method
}

// TypeScript (VALID after lifting):
class Array_1<T> {
    static sort<T, TKey>(keys: T[], items: TKey[]): void;  // ✅ OK: 'T' is now a method generic
}
```

**Algorithm:**

1. **Early exit if no class generics:**
   ```csharp
   if (declaringType.GenericParameters.Length == 0)
       return method;  // Nothing to lift
   ```

2. **Collect class generic parameters:**
   ```csharp
   var classGenerics = declaringType.GenericParameters.ToList();
   ```

3. **Check for name collisions with existing method generics:**
   ```csharp
   var existingMethodGenericNames = new HashSet<string>(
       method.GenericParameters.Select(gp => gp.Name)
   );
   ```

4. **Rename colliding class generics:**
   - For each class generic parameter:
     - If name collides with method generic: `T` → `T1`, `T2`, etc.
     - Build substitution map: `oldName → GenericParameterReference(newName)`
     - Example: Class has `T`, method has `T` → lift as `T1` to avoid collision

5. **Combine generics:**
   ```csharp
   var combinedGenerics = liftedGenerics
       .Concat(method.GenericParameters)
       .ToImmutableArray();
   ```
   - **Order**: Lifted class generics FIRST, then method generics
   - Ensures class generic positions match class declaration order

6. **Substitute renamed generics in signatures:**
   - If any generics were renamed (substitution map not empty):
     - Substitute in return type: `SubstituteTypeReference(method.ReturnType, substitutionMap)`
     - Substitute in parameters: For each param, substitute param type
   - Uses `Load.InterfaceMemberSubstitution.SubstituteTypeReference()`

7. **Return transformed method:**
   ```csharp
   return method with {
       GenericParameters = combinedGenerics,
       ReturnType = newReturnType,
       Parameters = newParameters
   };
   ```

**Examples:**

**Example 1: Simple lifting (no collision)**
```csharp
// Input: class Array<T> { static void Sort(T[] array) }
// Class generics: [T]
// Method generics: []
// Output: static sort<T>(array: T[]): void
```

**Example 2: Collision renaming**
```csharp
// Input: class Comparer<T> { static int Compare<T>(T x, T y) }
// Class generics: [T]           (outer T)
// Method generics: [T]          (inner T, shadows outer)
// Collision: Both named 'T'
// Output: static compare<T1, T>(x: T1, y: T): int
//         (class T lifted as T1, method T keeps name T)
```

**Example 3: Multiple class generics**
```csharp
// Input: class Dictionary<TKey, TValue> { static Dictionary<TKey, TValue> Create() }
// Class generics: [TKey, TValue]
// Method generics: []
// Output: static create<TKey, TValue>(): Dictionary_2<TKey, TValue>
```

**Logging:**
```csharp
ctx.Log("GenericLift", $"Lifted {liftedGenerics.Count} class generics into method {type.ClrName}.{method.ClrName}");
```

### Method: SubstituteClassGenericsInTypeRef() (**NEW in jumanji7**)

```csharp
private static TypeReference SubstituteClassGenericsInTypeRef(
    TypeReference typeRef,
    ImmutableArray<GenericParameterSymbol> classGenerics)
```

**Purpose:** Substitutes class-level generic parameter references with `unknown` type. Used for static fields/properties that cannot be made generic in TypeScript.

**Problem it solves:**

```typescript
// TypeScript does NOT support this:
class List<T> {
    static empty: T;        // ❌ TS2302: Static member cannot reference class type parameter 'T'
    static default: T[];    // ❌ TS2302: Cannot reference 'T'
}

// TypeScript DOES support this (widened to unknown):
class List_1<T> {
    static empty: unknown;        // ✅ OK: Widened type
    static default: unknown[];    // ✅ OK: Array of unknown (still TS2302, but safer)
}
```

**Algorithm:**

1. **Early exit if no class generics:**
   ```csharp
   if (classGenerics.Length == 0)
       return typeRef;  // Nothing to substitute
   ```

2. **Build class generic name set:**
   ```csharp
   var classGenericNames = new HashSet<string>(classGenerics.Select(gp => gp.Name));
   ```

3. **Check if type references any class generic:**
   ```csharp
   if (ReferencesClassGeneric(typeRef, classGenericNames))
   {
       // Widen to 'unknown'
       return new NamedTypeReference {
           AssemblyName = "TypeScript",
           Namespace = "",
           Name = "unknown",
           FullName = "unknown",
           Arity = 0,
           TypeArguments = ImmutableArray<TypeReference>.Empty,
           IsValueType = false
       };
   }
   ```

4. **Return original if no class generics referenced:**
   ```csharp
   return typeRef;
   ```

**Examples:**

**Example 1: Simple substitution**
```csharp
// Field type: T
// Class generics: [T]
// Result: unknown
```

**Example 2: Array substitution**
```csharp
// Field type: T[]
// Class generics: [T]
// Result: unknown  (entire type widened, not unknown[])
```

**Example 3: Complex type substitution**
```csharp
// Field type: Dictionary<TKey, TValue>
// Class generics: [TKey, TValue]
// Result: unknown  (entire type widened)
```

**Example 4: No substitution (doesn't reference class generics)**
```csharp
// Field type: string
// Class generics: [T]
// Result: string  (unchanged, doesn't reference T)
```

**Why widen entire type:**
- TypeScript cannot express "array of some class generic"
- Widening to `unknown[]` would still cause TS2302
- Safest approach: widen entire type to `unknown`
- Alternative: Could use `any`, but `unknown` is safer (forces type checking at use site)

### Method: ReferencesClassGeneric() (**NEW in jumanji7**)

```csharp
private static bool ReferencesClassGeneric(TypeReference typeRef, HashSet<string> classGenericNames)
```

**Purpose:** Recursively checks if a TypeReference contains any class-level generic parameters.

**Algorithm by TypeReference kind:**

```csharp
GenericParameterReference gp =>
    classGenericNames.Contains(gp.Name)
    // Direct match: T references class generic T

ArrayTypeReference arr =>
    ReferencesClassGeneric(arr.ElementType, classGenericNames)
    // Recurse: T[] contains T

PointerTypeReference ptr =>
    ReferencesClassGeneric(ptr.PointeeType, classGenericNames)
    // Recurse: T* contains T

ByRefTypeReference byref =>
    ReferencesClassGeneric(byref.ReferencedType, classGenericNames)
    // Recurse: ref T contains T

NamedTypeReference named =>
    named.TypeArguments.Any(arg => ReferencesClassGeneric(arg, classGenericNames))
    // Recurse: List<T> contains T, Dictionary<string, T> contains T

NestedTypeReference nested =>
    nested.FullReference.TypeArguments.Any(arg => ReferencesClassGeneric(arg, classGenericNames))
    // Recurse: Outer<T>.Inner contains T

_ => false
    // Unknown types: assume no class generics
```

**Examples:**

| Type Reference | Class Generics | Result | Reason |
|---|---|---|---|
| `T` | `{T}` | `true` | Direct match |
| `string` | `{T}` | `false` | Doesn't reference T |
| `T[]` | `{T}` | `true` | Element type is T |
| `List<T>` | `{T}` | `true` | Type arg is T |
| `List<string>` | `{T}` | `false` | Type arg is string, not T |
| `Dictionary<TKey, string>` | `{TKey, TValue}` | `true` | First type arg is TKey |
| `Dictionary<string, int>` | `{TKey, TValue}` | `false` | No type args reference class generics |
| `Nullable<T>` | `{T}` | `true` | Type arg is T |
| `ref T` | `{T}` | `true` | Referenced type is T |

**Why recursive:**
- Generic type arguments can nest: `List<Dictionary<TKey, TValue>>`
- Arrays can be generic: `T[]`
- Pointers/refs wrap types: `ref T`, `T*`
- Must check all levels to find class generic references

---

## FIX D: Interface and Base Class Generic Parameter Substitution

**Purpose:** Substitutes generic parameters when members come from interfaces or base classes with different generic parameter names. Prevents "orphaned generic parameter" errors where class surface methods reference type parameters not declared in the class.

**Problem solved:**
```csharp
// C# interface with generic T
interface IEnumerable<T> {
    T First();
}

// Class implements with concrete type string
class MyCollection : IEnumerable<string> {
    // WITHOUT FIX D: Member still references "T" (orphaned - not declared in MyCollection)
    T First();  // ❌ ERROR: T is not defined

    // WITH FIX D: T is substituted with string
    string First();  // ✅ CORRECT
}
```

**Files**: ClassPrinter.cs (15 methods), InterfaceInliner.cs (5 methods)
**Lines**: ~450 lines total
**Impact**: Eliminates orphaned generic parameter references in emitted TypeScript

### Entry Points (2 methods)

#### `SubstituteMemberIfNeeded(TypeSymbol type, MethodSymbol method, BuildContext ctx, SymbolGraph graph)`

**Purpose**: Determines if method needs generic parameter substitution and dispatches to appropriate handler.

**Algorithm:**
1. **Check Source Interface**: If `method.SourceInterface != null` → call `SubstituteInterfaceMethod()`
2. **Check Orphaned Generics**: If method references generics not in type → call `SubstituteBaseClassMethod()`
3. **Return original**: No substitution needed

**Example:**
```csharp
// Method from IEnumerable<string> interface
method.SourceInterface = IEnumerable`1
→ SubstituteInterfaceMethod() called
→ T substituted with string
```

#### `SubstituteMemberIfNeeded(TypeSymbol type, PropertySymbol prop, BuildContext ctx, SymbolGraph graph)`

**Purpose**: Property equivalent of method substitution.

**Algorithm:**
1. **Check Source Interface**: If `prop.SourceInterface != null` → call `SubstituteInterfaceProperty()`
2. **Check Orphaned Generics**: If property type references generics not in type → call `SubstituteBaseClassProperty()`
3. **Return original**: No substitution needed

### Interface Substitution (2 methods)

#### `SubstituteInterfaceMethod(TypeSymbol type, MethodSymbol method, BuildContext ctx, SymbolGraph graph)`

**Purpose**: Substitutes generic parameters for methods from interfaces.

**Algorithm:**
1. **Match interface**: Call `FindMatchingInterfaceForMember(type, method.SourceInterface)`
   - Matches `IEnumerable\`1` (open) to `IEnumerable<string>` (constructed)
2. **Find interface symbol**: Get interface TypeSymbol from graph to access generic parameter names
3. **Build substitution map**: Call `BuildSubstitutionMapForClass(matchedInterface, ifaceSymbol)`
   - Creates mapping: `{"T" → string}`
4. **Filter method generics**: Exclude method-level generic parameters from substitution
5. **Substitute types**: Apply to return type and all parameters
6. **Return transformed method**

**Example:**
```csharp
// Input: T First() from IEnumerable<string>
// matchedInterface: IEnumerable<string>
// substitutionMap: {"T" → string}
// Output: string First()
```

#### `SubstituteInterfaceProperty(TypeSymbol type, PropertySymbol prop, BuildContext ctx, SymbolGraph graph)`

**Purpose**: Property equivalent of interface method substitution.

**Algorithm**: Similar to `SubstituteInterfaceMethod` but only substitutes property type (no parameters).

### Base Class Substitution (2 methods)

#### `SubstituteBaseClassMethod(TypeSymbol type, MethodSymbol method, BuildContext ctx, SymbolGraph graph)`

**Purpose**: Substitutes generic parameters for methods inherited from base classes.

**Algorithm:**
1. **Find base class symbol**: Get base TypeSymbol from graph
2. **Build substitution map**: Map base class generic params → actual type args
3. **Substitute types**: Apply to return type and parameters
4. **Return transformed method**

**Example:**
```csharp
// Base class: List<T> with method T GetItem(int index)
// Derived class: MyList : List<string>
// Substitution map: {"T" → string}
// Output: string GetItem(int index)
```

#### `SubstituteBaseClassProperty(TypeSymbol type, PropertySymbol prop, BuildContext ctx, SymbolGraph graph)`

**Purpose**: Property equivalent of base class method substitution.

### Orphaned Generic Detection (3 methods)

#### `HasOrphanedGenericParameters(TypeSymbol type, MethodSymbol method)`

**Purpose**: Checks if method references generic parameters not declared in the type.

**Algorithm:**
1. Build set of type's generic parameter names
2. Build set of method's generic parameter names (method-level generics)
3. Call `ContainsOrphanedGenericParameter()` on return type and all parameters
4. Return true if any orphaned generics found

**Example:**
```csharp
// Type MyList (no generics)
// Method: T GetItem(int index) where T from base class
// → HasOrphanedGenericParameters returns true (T is orphaned)
```

#### `HasOrphanedGenericParametersInProperty(TypeSymbol type, PropertySymbol prop)`

**Purpose**: Property equivalent of orphaned generic detection.

#### `ContainsOrphanedGenericParameter(TypeReference typeRef, HashSet<string> typeGenericParams, HashSet<string> methodGenericParams)`

**Purpose**: Recursively checks if TypeReference contains generic parameters not in type or method.

**Algorithm by TypeReference kind:**
- **GenericParameterReference**: Check if name is in typeGenericParams or methodGenericParams
- **NamedTypeReference**: Recurse into type arguments
- **NestedTypeReference**: Recurse into full reference type arguments
- **ArrayTypeReference**: Recurse into element type
- **PointerTypeReference/ByRefTypeReference**: Recurse into pointee/referenced type

### Interface Matching (2 methods)

#### `FindMatchingInterfaceForMember(TypeSymbol type, TypeReference sourceInterface)`

**Purpose**: Matches an open generic interface reference to the class's actual (constructed) interface implementation.

**Algorithm:**
1. Get interface base name: `IEnumerable` from `IEnumerable\`1`
2. Search type's interface list for matching base name
3. Return first match (constructed interface with actual type arguments)

**Example:**
```csharp
// Class implements: IEnumerable<string>, ICollection<string>
// SourceInterface: IEnumerable`1 (open)
// → Finds and returns: IEnumerable<string> (constructed)
```

#### `GetInterfaceBaseName(TypeReference typeRef)`

**Purpose**: Extracts base name without generic arity.

**Examples:**
- `IEnumerable\`1` → `IEnumerable`
- `Dictionary\`2` → `Dictionary`

### Substitution Map Building (1 method)

#### `BuildSubstitutionMapForClass(TypeReference actualInterface, TypeSymbol interfaceSymbol)`

**Purpose**: Builds mapping from interface generic parameter names to actual type arguments.

**Algorithm:**
1. Get actual type arguments from constructed interface: `IEnumerable<string>` → `[string]`
2. Get generic parameter names from interface symbol: `IEnumerable\`1<T>` → `["T"]`
3. Zip together: `{"T" → string}`

**Example:**
```csharp
// actualInterface: Dictionary<string, int>
// interfaceSymbol: IDictionary`2<TKey, TValue>
// Result: {"TKey" → string, "TValue" → int}
```

### Symbol Lookup (3 methods)

#### `FindInterfaceSymbol(SymbolGraph graph, TypeReference interfaceRef)`

**Purpose**: Finds interface TypeSymbol in graph by CLR full name.

**Algorithm:**
1. Get CLR full name from reference
2. Search all namespaces for matching interface
3. Return TypeSymbol (null if not found)

**Used for**: Getting interface's generic parameter names for substitution map building.

#### `FindTypeSymbol(SymbolGraph graph, TypeReference typeRef)`

**Purpose**: Finds any TypeSymbol in graph by CLR full name.

**Used for**: Finding base class symbols for base class substitution.

#### `GetTypeFullName(TypeReference typeRef)`

**Purpose**: Helper to extract CLR full name from TypeReference.

**Handles**: NamedTypeReference, NestedTypeReference

### Signature Changes

**PrintClass(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx, SymbolGraph graph, bool instanceSuffix = false)**
- **Added parameter**: `SymbolGraph graph` (needed for FIX D lookups)

**PrintStruct(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx, SymbolGraph graph, bool instanceSuffix = false)**
- **Added parameter**: `SymbolGraph graph`

**EmitMembers(StringBuilder sb, TypeSymbol type, TypeNameResolver resolver, BuildContext ctx, SymbolGraph graph)**
- **Added parameter**: `SymbolGraph graph`
- **Calls**: `SubstituteMemberIfNeeded()` for all methods and properties before emitting

### Integration

**Called from**: `EmitMembers()` before emitting each method/property

```csharp
// In EmitMembers:
foreach (var method in members.Methods) {
    var methodToEmit = SubstituteMemberIfNeeded(type, method, ctx, graph); // FIX D
    sb.Append(MethodPrinter.Print(methodToEmit, type, resolver, ctx));
}

foreach (var prop in members.Properties) {
    var propToEmit = SubstituteMemberIfNeeded(type, prop, ctx, graph); // FIX D
    // ... emit property
}
```

---

## File: Printers/MethodPrinter.cs

### Purpose
Prints TypeScript method signatures from MethodSymbol. Handles generic methods, parameters, return types, and modifiers.

### Method: Print()
```csharp
public static string Print(MethodSymbol method, TypeSymbol declaringType, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
1. Gets final TS name from Renamer using `ClassSurface` scope
2. Emits modifiers (`static`, `abstract`) - SKIPPED for interface members
3. Emits method name
4. Emits generic parameters with constraints
5. Emits parameters
6. Emits return type

**Key Decision:**
- Interface members don't get `static`/`abstract` modifiers (TS doesn't support static interface members)

### Method: PrintGenericParameter()
```csharp
private static string PrintGenericParameter(GenericParameterSymbol gp, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints generic parameter with constraints
- Single constraint: `T extends IFoo`
- Multiple constraints: `T extends IFoo & IBar`

### Method: PrintParameter()
```csharp
private static string PrintParameter(ParameterSymbol param, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints parameter name
- Adds `?` for optional parameters (has default value)
- Handles ref/out parameters: `{ value: T }` wrapper (metadata tracks semantics)
- Handles params parameters: caller adds `...` prefix

### Method: PrintWithParamsExpansion()
```csharp
public static string PrintWithParamsExpansion(MethodSymbol method, TypeSymbol declaringType, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Converts params array to rest parameter syntax
- Example: `Add(items: T[])` → `Add(...items: T[])`
- Only applies to last parameter if `IsParams` is true

### Method: PrintOverloads()
```csharp
public static IEnumerable<string> PrintOverloads(IEnumerable<MethodSymbol> overloads, TypeSymbol declaringType, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints multiple method overloads (same name, different signatures)
- Yields one string per overload

### Method: PrintAsPropertyAccessor()
```csharp
public static string PrintAsPropertyAccessor(MethodSymbol method, bool isGetter, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints method as property getter/setter
- Extracts property name from method name (`get_Foo` → `Foo`)
- Used for interface property accessors

---

## File: Printers/TypeRefPrinter.cs

### Purpose
Prints TypeScript type references from TypeReference model. Handles all type constructs: named, generic parameters, arrays, pointers, byrefs, nested. **CRITICAL:** Uses TypeNameResolver to ensure printed names match imports (single source of truth).

### Method: Print()
```csharp
public static string Print(TypeReference typeRef, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Dispatches to specialized printer based on type reference kind:
  - `PlaceholderTypeReference` → `PrintPlaceholder()` (emits warning, returns `any`)
  - `NamedTypeReference` → `PrintNamed()`
  - `GenericParameterReference` → `PrintGenericParameter()`
  - `ArrayTypeReference` → `PrintArray()`
  - `PointerTypeReference` → `PrintPointer()`
  - `ByRefTypeReference` → `PrintByRef()`
  - `NestedTypeReference` → `PrintNested()`

### Method: PrintPlaceholder()
```csharp
private static string PrintPlaceholder(PlaceholderTypeReference placeholder, BuildContext ctx)
```
**What it does:**
- Emits diagnostic warning (placeholders should never reach output)
- Returns `"any"` as fallback

### Method: PrintNamed()
```csharp
private static string PrintNamed(NamedTypeReference named, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
1. Tries to map CLR primitive via `TypeNameResolver.TryMapPrimitive()` (short-circuit)
2. Gets final TypeScript name from `resolver.ResolveTypeName(named)`
3. Validates non-empty name (emits warning if empty)
4. Handles generic type arguments recursively
5. Returns `TypeName<T, U>` or plain `TypeName`

**Key Algorithm:**
```csharp
// 1. Map primitive (System.Int32 → int)
var primitiveType = TypeNameResolver.TryMapPrimitive(named.FullName);
if (primitiveType != null) return primitiveType;

// 2. Get final name from resolver (handles both graph types and external types)
var baseName = resolver.ResolveTypeName(named);

// 3. HARDENING: Validate non-empty
if (string.IsNullOrWhiteSpace(baseName))
{
    ctx.Diagnostics.Warning(...);
    return "unknown";
}

// 4. Handle generic arguments recursively
if (named.TypeArguments.Count > 0)
{
    var args = string.Join(", ", named.TypeArguments.Select(arg => Print(arg, resolver, ctx)));
    return $"{baseName}<{args}>";
}

return baseName;
```

### Method: PrintGenericParameter()
```csharp
private static string PrintGenericParameter(GenericParameterReference gp)
```
**What it does:**
- Returns generic parameter name as-is: `T`, `U`, `TKey`, `TValue`

### Method: PrintArray()
```csharp
private static string PrintArray(ArrayTypeReference arr, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Single-dimensional: `T[]`
- Multi-dimensional: `Array<Array<T>>` (nested)

### Method: PrintPointer()
```csharp
private static string PrintPointer(PointerTypeReference ptr, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Returns `TSUnsafePointer<T>` where T is the pointee type
- Preserves type information while being type-safe (erases to `unknown`)

### Method: PrintByRef()
```csharp
private static string PrintByRef(ByRefTypeReference byref, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Returns `TSByRef<T>` where T is the referenced type
- Provides structural access via `.value` property

### Method: PrintNested()
```csharp
private static string PrintNested(NestedTypeReference nested, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Nested types use resolver just like named types
- The `FullReference` is a `NamedTypeReference` that the resolver handles correctly

### Helper Methods

#### PrintList()
```csharp
public static string PrintList(IEnumerable<TypeReference> typeRefs, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints comma-separated list of type references
- Used for generic parameter lists, method parameters

#### PrintNullable()
```csharp
public static string PrintNullable(TypeReference typeRef, bool isNullable, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints type with optional nullability: `T | null`

#### PrintReadonlyArray()
```csharp
public static string PrintReadonlyArray(TypeReference elementType, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints `ReadonlyArray<T>` for IEnumerable<T> mappings

#### PrintPromise()
```csharp
public static string PrintPromise(TypeReference resultType, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints `Promise<T>` for Task<T> mappings

#### PrintTuple()
```csharp
public static string PrintTuple(IReadOnlyList<TypeReference> elementTypes, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints tuple type: `[T1, T2, T3]`

#### PrintUnion()
```csharp
public static string PrintUnion(IReadOnlyList<TypeReference> types, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints union type: `T1 | T2 | T3`

#### PrintIntersection()
```csharp
public static string PrintIntersection(IReadOnlyList<TypeReference> types, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints intersection type: `T1 & T2 & T3`

#### PrintTypeof()
```csharp
public static string PrintTypeof(TypeReference typeRef, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints typeof expression: `typeof ClassName`

---

## Output File Format Examples

### 1. index.d.ts (Facade)

```typescript
// Generated by tsbindgen - Single-Phase Architecture
// Namespace: System.Collections.Generic
// Facade - Public API Surface

// Import internal declarations
import * as Internal from './internal/index';

// Import dependencies
import * as System from '../System/index';

// Re-export namespace
export import Generic = Internal.System.Collections.Generic;

// Individual type exports for convenience
export type List_1 = Internal.System.Collections.Generic.List_1;
export type Dictionary_2 = Internal.System.Collections.Generic.Dictionary_2;
export type IEnumerable_1 = Internal.System.Collections.Generic.IEnumerable_1;
```

### 2. internal/index.d.ts (Declarations)

```typescript
// Generated by tsbindgen - Single-Phase Architecture
// Namespace: System.Collections.Generic
// Assembly: System.Private.CoreLib

// Branded primitive types for CLR numeric types
export type sbyte = number & { __brand: "sbyte" };
export type byte = number & { __brand: "byte" };
export type int = number & { __brand: "int" };
// ... all primitives ...

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../_support/types";

// Import types from other namespaces
import type { Object, ValueType } from "../System/internal/index";

export namespace System.Collections.Generic {
    export class List_1$instance<T> {
        constructor(capacity: int);
        readonly Count: int;
        Add(item: T): void;
        GetEnumerator(): IEnumerator_1<T>;
    }

    export interface __List_1$views<T> {
        readonly IEnumerable_1$view: IEnumerable_1<T>;
    }

    export type List_1<T> = List_1$instance<T> & __List_1$views<T>;

    export interface IEnumerable_1<T> {
        GetEnumerator(): IEnumerator_1<T>;
    }
}
```

### 3. internal/metadata.json

```json
{
  "Namespace": "System.Collections.Generic",
  "ContributingAssemblies": [
    "System.Private.CoreLib"
  ],
  "Types": [
    {
      "ClrName": "System.Collections.Generic.List`1",
      "TsEmitName": "List_1",
      "Kind": "Class",
      "Accessibility": "Public",
      "IsAbstract": false,
      "IsSealed": false,
      "IsStatic": false,
      "Arity": 1,
      "Methods": [
        {
          "ClrName": "Add",
          "TsEmitName": "Add",
          "NormalizedSignature": "Add(T):System.Void",
          "Provenance": "Direct",
          "EmitScope": "ClassSurface",
          "IsStatic": false,
          "IsAbstract": false,
          "IsVirtual": false,
          "IsOverride": false,
          "IsSealed": false,
          "Arity": 0,
          "ParameterCount": 1
        }
      ],
      "Properties": [],
      "Fields": [],
      "Events": [],
      "Constructors": []
    }
  ]
}
```

### 4. bindings.json

```json
{
  "Namespace": "System.Collections.Generic",
  "Types": [
    {
      "ClrName": "System.Collections.Generic.List`1",
      "TsEmitName": "List_1",
      "AssemblyName": "System.Private.CoreLib",
      "MetadataToken": 0,
      "Methods": [
        {
          "ClrName": "Add",
          "TsEmitName": "Add",
          "MetadataToken": 100663359,
          "CanonicalSignature": "Add(!0):System.Void",
          "NormalizedSignature": "Add(T):System.Void",
          "EmitScope": "ClassSurface",
          "Arity": 0,
          "ParameterCount": 1
        }
      ],
      "Properties": [],
      "Fields": [],
      "Events": [],
      "Constructors": []
    }
  ]
}
```

### 5. index.js (Stub)

```javascript
// Generated by tsbindgen - Single-Phase Architecture
// Namespace: System.Collections.Generic
// Module Stub - Do Not Execute

throw new Error(
  'Cannot import CLR namespace System.Collections.Generic in JavaScript runtime. ' +
  'This module provides TypeScript type definitions only. ' +
  'Actual implementation requires .NET runtime via Tsonic compiler.'
);
```

### 6. _support/types.d.ts

```typescript
// Generated by tsbindgen - Single-Phase Architecture
// Support Types Module
//
// These are opaque placeholders for CLR constructs that have no TS equivalent.
// They intentionally erase to `unknown` to keep the API sound.

/**
 * Marker type for C# pointer types (void*, int*, T*, etc.).
 * Erases to `unknown` for type safety - forces explicit handling.
 * The generic parameter preserves information about the pointed-to type.
 * Branded with unique symbol to maintain identity for auditing.
 */
export type TSUnsafePointer<T> = unknown & { readonly __tsbindgenPtr?: unique symbol };

/**
 * Marker type for C# ref/out/in parameters.
 * Provides structural access via `.value` to match C# semantics.
 * Branded with unique symbol to maintain identity for auditing.
 * Example: `method(arg: TSByRef<int>)` → caller uses `arg.value`
 */
export type TSByRef<T> = { value: T } & { readonly __tsbindgenByRef?: unique symbol };
```

---

## Key Design Decisions

### 1. Companion Views Pattern

**Problem:** TypeScript doesn't support structural intersection for class implementation checking.

**Solution:**
- Emit `TypeName$instance` class with ClassSurface members
- Emit `__TypeName$views` interface with ViewOnly members
- Emit `type TypeName = TypeName$instance & __TypeName$views`

**Benefits:**
- Class surface remains clean (no view member clutter)
- Views are type-checked via intersection
- Consumers get both class and view members via single type

### 2. Branded Primitive Types

**Problem:** TypeScript `number` type can't distinguish `int` vs `float` vs `decimal`.

**Solution:**
- Emit branded type aliases: `type int = number & { __brand: "int" };`
- All namespaces get these (needed for cross-namespace references)

**Benefits:**
- Type safety for CLR numeric types
- No runtime overhead (erases to `number`)
- Intentional misuse detection (can't pass `float` where `int` expected)

### 3. Unsafe Type Markers

**Problem:** TypeScript has no pointers or ref parameters.

**Solution:**
- Centralized `_support/types.d.ts` with marker types
- `TSUnsafePointer<T>` for pointers (erases to `unknown`)
- `TSByRef<T>` for ref/out/in (structural `{ value: T }`)

**Benefits:**
- Type-safe (forces explicit handling)
- Preserves type information
- Branded for auditing
- Single import location

### 4. EmitScope Filtering

**Problem:** Not all members should appear in declarations (some are view-only).

**Solution:**
- `ClassSurface` members → class body
- `StaticSurface` members → static members
- `ViewOnly` members → companion views interface

**Benefits:**
- Clean separation of concerns
- No duplicate members in class surface
- Explicit interface implementations in views

### 5. TypeNameResolver Single Source of Truth

**Problem:** Name mismatches between imports and declarations cause errors.

**Solution:**
- All name resolution goes through `TypeNameResolver`
- Resolver queries `Renamer` for final names
- Never use CLR names directly in printers

**Benefits:**
- Guaranteed name consistency
- Suffix handling in one place
- Easy to audit (single code path)

---

## Summary

The **Emit Phase** is the final phase that generates all output files from the validated `EmissionPlan`. It consists of multiple specialized emitters:

1. **FacadeEmitter** - Public-facing facades with re-exports
2. **InternalIndexEmitter** - Actual TypeScript declarations with companion views
3. **MetadataEmitter** - CLR-specific metadata for Tsonic compiler
4. **BindingEmitter** - CLR-to-TypeScript name mappings for runtime
5. **ModuleStubEmitter** - JavaScript stubs that prevent execution
6. **SupportTypesEmitter** - Centralized unsafe type markers

All emitters use:
- **TypeNameResolver** for consistent type names (single source of truth)
- **Renamer** for final TypeScript identifiers (suffix handling)
- **EmitScope** for member filtering (ClassSurface/StaticSurface/ViewOnly)
- **EmitOrder** for deterministic output (stable across runs)

The output includes:
- **TypeScript declarations** - `.d.ts` files with type definitions
- **Metadata sidecars** - `.json` files with CLR information
- **Binding metadata** - `.json` files with name mappings
- **Module stubs** - `.js` files that throw at runtime
- **Support types** - Centralized marker types for unsafe constructs

All output is deterministic, type-safe, and respects the single-phase architecture's guarantees.
